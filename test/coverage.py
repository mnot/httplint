#!/usr/bin/env python3
"""
Check that all Note classes are generated by the test suite.
"""

import sys
import pytest
from typing import Set, types, Dict, Any, Type

from httplint.note import Note
from test.utils import checkSubClasses

import ast
import os
import re
from collections import defaultdict

# Tracking set for covered notes
covered_notes: Set[types.ModuleType] = set()
static_missing_vars: Dict[str, Set[str]] = defaultdict(set)

# Map note name to class for static analysis
note_name_to_class: Dict[str, Type[Note]] = {}

# Monkeypatch Note.__init__ to track coverage
original_init = Note.__init__

def tracking_init(self: Note, subject: str, **vars: Any) -> None:
    covered_notes.add(self.__class__)
    original_init(self, subject, **vars)

Note.__init__ = tracking_init


def collect_defined_notes() -> Set[types.ModuleType]:
    """
    Collect all defined Note subclasses.
    """
    defined_notes = set()

    def collector(note_cls):
         # Skip the base Note class if strictly subclass checking, 
         # but checkSubClasses walks subclasses.
         # We want concrete Note classes.
         # Assuming all subclasses of Note are concrete enough or intended to be used.
         # We might want to filter out intermediate base classes if any.
         # For now, let's collect all.
         defined_notes.add(note_cls)
         note_name_to_class[note_cls.__name__] = note_cls
         return 0

    paths = ["httplint", "httplint/field", "httplint/field/parsers"]
    checkSubClasses(Note, paths, collector)
    return defined_notes


def check_static_usage():
    """
    Statically check all python files for Note usage and missing variables.
    """
    for root, dirs, files in os.walk("httplint"):
        for file in files:
            if not file.endswith(".py"):
                continue
            
            path = os.path.join(root, file)
            try:
                with open(path, "r", encoding="utf-8") as f:
                    tree = ast.parse(f.read(), filename=path)
            except Exception as e:
                print(f"Failed to parse {path}: {e}")
                continue

            for node in ast.walk(tree):
                if isinstance(node, ast.Call):
                    # Check for self.add_note(...) or something.add_note(...)
                    is_add_note = False
                    if isinstance(node.func, ast.Attribute) and node.func.attr == "add_note":
                        is_add_note = True
                    # Check for Notes.add(...) which might be called differently
                    # But mostly we look for the pattern add_note(..., NoteClass, ...)
                    
                    if not is_add_note:
                        continue

                    # In most calls we see: add_note(subject, NoteClass, **kwargs)
                    # or partial usage in status.py: add_note(subject, NoteClass) where partial bound the others.
                    # We need to find which arg is the Note class.
                    # Based on codebase, it's usually the 2nd arg (index 1).
                    
                    if len(node.args) < 2:
                        continue
                    
                    note_arg = node.args[1]
                    note_name = None
                    
                    if isinstance(note_arg, ast.Name):
                        note_name = note_arg.id
                    elif isinstance(note_arg, ast.Attribute):
                         note_name = note_arg.attr
                    
                    if not note_name or note_name not in note_name_to_class:
                        continue
                        
                    note_cls = note_name_to_class[note_name]
                    
                    # Calculate needed variables
                    content = getattr(note_cls, "_summary", "") + getattr(note_cls, "_text", "")
                    needed = set(re.findall(r"%\(([a-z0-9_]+)\)s", content))
                    
                    if not needed:
                        continue

                    # Calculate provided variables from keywords
                    provided = set()
                    for keyword in node.keywords:
                        if keyword.arg:
                            provided.add(keyword.arg)
                            
                    missing = needed - provided
                    if missing:
                         static_missing_vars[note_name].update(missing)


if __name__ == "__main__":
    print("Collecting defined Notes...")
    defined_notes = collect_defined_notes()
    print(f"Found {len(defined_notes)} Note definitions.")

    print("Running test suite to collect coverage...")
    # Run pytest on all tests, ignoring this file to avoid infinite recursion
    # -q: quiet
    # -p no:cacheprovider: disable parsing of .pytest_cache
    pytest_args = ["test", "--ignore=test/coverage.py", "-q"]
    retcode = pytest.main(pytest_args)

    if retcode != 0:
        print("Tests failed! Cannot determine coverage accurately.")
        sys.exit(retcode)

    print(f"\nCovered {len(covered_notes)} Notes.")

    missing_notes = defined_notes - covered_notes
    
    # Filter out Note itself
    if Note in missing_notes:
        missing_notes.remove(Note)

    exit_code = 0

    if missing_notes:
        print(f"\nMISSING COVERAGE: {len(missing_notes)} Notes were not generated during tests:")
        for note in sorted(missing_notes, key=lambda x: x.__name__):
            print(f"  - {note.__name__}")
        # Note: We do not fail the build for missing coverage, only for missing variables.
    
    print("\nRunning static analysis...")
    check_static_usage()
    
    if static_missing_vars:
        count = len(static_missing_vars)
        print(f"\nMISSING VARIABLES (Static): {count} Notes usages found with missing variables:")
        for note_name, vars in sorted(static_missing_vars.items()):
            print(f"  - {note_name}: {', '.join(sorted(vars))}")
        exit_code = 1

    if exit_code == 0:
        print("\nAll Notes are covered and have correct variables!")
    
    sys.exit(exit_code)
