# Chinese translations for PROJECT.
# Copyright (C) 2025 ORGANIZATION
# This file is distributed under the same license as the PROJECT project.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2025-12-02 12:04+1100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh\n"
"Language-Team: zh <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: httplint/cache.py:281
msgid "This response doesn't have a Date header."
msgstr "此响应缺少 Date 标头。"

#: httplint/cache.py:282
msgid ""
"Although HTTP allows a server not to send a `Date` header in responses if"
" it doesn't have a local\n"
"clock, this can make calculation of a stored response's age inexact."
msgstr "尽管 HTTP 允许服务器在没有本地时钟的情况下不发送 `Date` 头部，但这可能导致存储响应年龄的计算不准确。"

#: httplint/cache.py:290
msgid "This response has an Expires or Last-Modified header, but no Date."
msgstr "此响应具有 Expires 或 Last-Modified 标头，但缺少 Date 标头。"

#: httplint/cache.py:291
msgid ""
"Because both the `Expires` and `Last-Modified` headers are date-based, "
"it's necessary to send when\n"
"the message was generated in `Date` for them to be useful; otherwise, "
"clock drift, transit times\n"
"between nodes as well as caching could skew their application."
msgstr ""
"由于 `Expires` 和 `Last-Modified` 报头都是基于日期的，因此有必要发送生成消息的 `Date` "
"时间，以使它们有用；否则，时钟漂移、节点之间的传输时间以及缓存可能会导致其应用出现偏差。"

#: httplint/cache.py:300
#, python-format
msgid "Responses to the %(method)s method can't be stored by caches."
msgstr "缓存无法存储对 %(method)s 方法的响应。"

#: httplint/cache.py:308
msgid "This response can't be stored by caches."
msgstr "此响应无法被缓存存储。"

#: httplint/cache.py:309
msgid ""
"The `Cache-Control: no-store` directive indicates that this response "
"can't be stored by a cache."
msgstr "`Cache-Control: no-store` 指令表示此响应无法被缓存存储。"

#: httplint/cache.py:316
msgid "This response allows only private caches to store it."
msgstr "此响应仅允许私有缓存存储。"

#: httplint/cache.py:317
msgid ""
"The `Cache-Control: private` directive indicates that the response can "
"only be stored by caches\n"
"that are specific to a single user; for example, a browser cache. Shared "
"caches, such as those in\n"
"proxies, cannot store it."
msgstr ""
"`Cache-Control: private` "
"指令表明响应只能由特定于单个用户的缓存存储；例如，浏览器缓存。共享缓存（例如代理中的缓存）则不能存储它。"

#: httplint/cache.py:326
msgid ""
"This response contains both the `public` and `private` Cache-Control "
"directives."
msgstr "此响应同时包含 `public` 和 `private` Cache-Control 指令。"

#: httplint/cache.py:327
msgid ""
"`Cache-Control: public` and `Cache-Control: private` conflict; they "
"should not occur on the same message.\n"
"\n"
"Conservative caches will ignore `public` and honor `private`, but this "
"cannot be relied upon."
msgstr ""
"`Cache-Control: public` 和 `Cache-Control: private` 冲突；它们不应出现在同一消息中。\n"
"\n"
"保守的缓存会忽略 `public` 并遵守 `private`，但不能依赖这种行为。"

#: httplint/cache.py:336
msgid ""
"This response can only be stored by private caches, because the request "
"was authenticated."
msgstr "此响应只能由私有缓存存储，因为请求已通过身份验证。"

#: httplint/cache.py:338
msgid ""
"Because the request was authenticated and this response doesn't contain a"
" `Cache-Control: public`\n"
"directive, this response can only be stored by caches that are specific "
"to a single user; for\n"
"example, a browser cache. Shared caches, such as those in proxies, cannot"
" store it."
msgstr ""
"由于请求已通过身份验证，且此响应不包含 `Cache-Control: public` "
"指令，因此此响应只能由特定于单个用户的缓存存储；例如，浏览器缓存。共享缓存，如代理中的缓存，则无法存储它。"

#: httplint/cache.py:347
msgid ""
"This response can be stored by all caches, even though the request was "
"authenticated."
msgstr "此响应可以被所有缓存存储，即使请求已通过身份验证。"

#: httplint/cache.py:351
#, python-format
msgid ""
"Usually, responses to authenticated requests can't be stored by shared "
"caches. However, because\n"
"This response contains a `Cache-Control: %(directive)s` directive, it can"
" be stored by all caches,\n"
"including shared caches (like those in proxies)."
msgstr ""
"通常，对已认证请求的响应不能被共享缓存存储。然而，因为此响应包含一个`Cache-Control: "
"%(directive)s`指令，所以它可以被所有缓存存储，包括共享缓存（如代理中的缓存）。"

#: httplint/cache.py:360
msgid "Cache-Control: public is probably not necessary."
msgstr "Cache-Control: public 可能不是必需的。"

#: httplint/cache.py:361
msgid ""
"The `Cache-Control: public` directive allows caches to store and use "
"responses\n"
"in some circumstances when they would otherwise not be able to.\n"
"\n"
"For example, it allows responses to authenticated requests to be stored "
"by shared caches.\n"
"\n"
"Other responses **do not need to contain `public`**; it does not make the"
"\n"
"response \"more cacheable\", and only makes the response headers larger."
msgstr ""
"`Cache-Control: public` 指令允许缓存存储和使用响应，在某些情况下，即使它们在其他情况下无法做到。\n"
"\n"
"例如，它允许共享缓存存储已认证请求的响应。\n"
"\n"
"其他响应**不需要包含 `public`**；它不会使响应“更易于缓存”，只会使响应头更大。"

#: httplint/cache.py:374
msgid "This response allows all caches to store it."
msgstr "此响应允许所有缓存对其进行存储。"

#: httplint/cache.py:376
msgid ""
"A cache can store this response; it may or may not be able to use it to "
"satisfy a particular\n"
"request."
msgstr "缓存可以存储此响应；它可能能够也可能不能用它来满足特定请求。"

#: httplint/cache.py:384
msgid "This response allows only shared caches to store it."
msgstr "此响应仅允许共享缓存存储。"

#: httplint/cache.py:386
msgid ""
"A shared cache can store this response; it may or may not be able to use "
"it to satisfy a\n"
"particular request.\n"
"\n"
"Private caches cannot store it, because there is no explicit freshness "
"information\n"
"(such as Cache-Control: max-age), and the status code is not "
"heuristically cacheable.\n"
"\n"
"Note that a cache extension might override this behaviour."
msgstr ""
"共享缓存可以存储此响应；它可能能够也可能不能使用它来满足特定请求。\n"
"\n"
"私人缓存不能存储它，因为没有明确的新鲜度信息（如 Cache-Control: max-age），并且状态码不可启发式缓存。\n"
"\n"
"请注意，缓存扩展可能会覆盖此行为。"

#: httplint/cache.py:399
msgid "This response cannot be stored by caches."
msgstr "此响应无法被缓存。"

#: httplint/cache.py:400
msgid ""
"While caches can store many kinds of response as being heuristically "
"cacheable -- that is,\n"
"they can store them without explicit caching directives like Cache-"
"Control:max-age, this\n"
"reponse's status code is not defined as being heuristically cacheable, "
"and other directives\n"
"that would allow it to be stored (such as Cache-Control: public) are not "
"present.\n"
"\n"
"Note that a cache extension might override this behaviour."
msgstr ""
"尽管缓存可以存储多种响应，这些响应被认为是启发式可缓存的——也就是说，\n"
"它们可以在没有明确缓存指令（如 Cache-Control: max-age）的情况下存储它们，但此\n"
"响应的状态码并未定义为启发式可缓存，并且不允许存储它的其他指令（如 Cache-Control: public）\n"
"也不存在。\n"
"\n"
"请注意，缓存扩展可能会覆盖此行为。"

#: httplint/cache.py:412
msgid "This response cannot be served from cache without validation."
msgstr "此响应无法在不进行验证的情况下从缓存提供。"

#: httplint/cache.py:413
msgid ""
"The `Cache-Control: no-cache` directive means that while caches can store"
" this\n"
"response, they cannot use it to satisfy a request unless it has been "
"validated (either with an\n"
"`If-None-Match` or `If-Modified-Since` conditional) for that request."
msgstr ""
"`Cache-Control: no-cache` 指令意味着缓存可以存储此响应，但除非已（使用 `If-None-Match` 或 `If-"
"Modified-Since` 条件）对该请求进行过验证，否则不能用它来满足请求。"

#: httplint/cache.py:422
msgid ""
"This response cannot be served from cache without validation, and doesn't"
" have a validator."
msgstr "此响应无法在无需验证的情况下从缓存提供，并且没有验证器。"

#: httplint/cache.py:424
msgid ""
"The `Cache-Control: no-cache` directive means that while caches can store"
" this response, they\n"
"cannot use it to satisfy a request unless it has been validated (either "
"with an `If-None-Match` or\n"
"`If-Modified-Since` conditional) for that request.\n"
"\n"
"This response doesn't have a `Last-Modified` or `ETag` header, so it "
"effectively can't be used by a\n"
"cache. `Cache-Control: no-store` is more appropriate."
msgstr ""
"`Cache-Control: no-cache` 指令意味着缓存可以存储此响应，但除非已通过（使用 `If-None-Match` 或 `If-"
"Modified-Since` 条件）验证，否则不能将其用于满足请求。\n"
"\n"
"此响应没有 `Last-Modified` 或 `ETag` 标头，因此缓存实际上无法使用它。`Cache-Control: no-store` "
"更合适。"

#: httplint/cache.py:436
#, python-format
msgid "This response has already been cached for %(age)s."
msgstr "此响应已缓存%(age)s。"

#: httplint/cache.py:437
msgid ""
"HTTP defines an algorithm that uses the `Age` header, `Date` header, and "
"local time observations to\n"
"determine the age of a response. As a result, caches might use a value "
"other than that in the `Age`\n"
"header to determine how old the response is -- and therefore how much "
"longer it can be used."
msgstr ""
"HTTP 定义了一种算法，它使用 `Age` 标头、`Date` 标头和本地时间观察来确定响应的年龄。因此，缓存可能使用 `Age` "
"标头之外的值来确定响应的旧程度——从而确定它还能使用多长时间。"

#: httplint/cache.py:446
#, python-format
msgid "This response is fresh for %(freshness_left)s."
msgstr "此响应在 %(freshness_left)s 后过期。"

#: httplint/cache.py:447
#, python-format
msgid ""
"A response can be considered fresh when its age (here, %(current_age)s) "
"is less than its freshness\n"
"lifetime (in this case, %(freshness_lifetime)s)."
msgstr ""
"当响应的年龄（此处为 %(current_age)s）小于其新鲜度有效期（此处为 "
"%(freshness_lifetime)s）时，该响应可被视为新鲜。"

#: httplint/cache.py:455
#, python-format
msgid ""
"This response is %(private_status)s for %(fresh_left)s (%(shared_status)s"
" for %(share_left)s in shared caches)."
msgstr "此响应的%(private_status)s为%(fresh_left)s（在共享缓存中的%(shared_status)s为%(share_left)s）。"

#: httplint/cache.py:459
#, python-format
msgid ""
"This response has different freshness lifetimes for private (e.g., "
"browser) and shared (e.g., proxy)\n"
"caches.\n"
"\n"
"Private caches can consider it fresh for %(fresh_lifetime)s (until "
"%(fresh_left)s from\n"
"now).\n"
"\n"
"Shared caches can consider it fresh for %(share_lifetime)s (until "
"%(share_left)s from now)."
msgstr ""
"此响应对于私有（例如浏览器）和共享（例如代理）缓存具有不同的新鲜度寿命。\n"
"\n"
"私有缓存可认为其在 %(fresh_lifetime)s 内（即从现在起 %(fresh_left)s）是新鲜的。\n"
"\n"
"共享缓存可认为其在 %(share_lifetime)s 内（即从现在起 %(share_left)s）是新鲜的。"

#: httplint/cache.py:472
msgid "This response is stale."
msgstr "此响应已过时。"

#: httplint/cache.py:473
#, python-format
msgid ""
"A HTTP response is stale when its age (here, %(current_age)s) is equal to"
" or exceeds\n"
"its freshness lifetime (in this case, %(freshness_lifetime)s).\n"
"\n"
"There are a few reasons why a cache might serve a stale response:\n"
"\n"
"* HTTP allows stale responses to be used to satisfy requests in "
"exceptional circumstances;\n"
"e.g., when they lose contact with the origin server. This is subject to a"
" number of requirements.\n"
"* Response directives like `stale-if-error` and `stale-while-revalidate` "
"explicitly allow stale\n"
"  responses to be used in particular circumstances.\n"
"* Some caches are configured to ignore the response's freshness "
"directives."
msgstr ""
"当 HTTP 响应的年龄（此处为 %(current_age)s）等于或超过其新鲜度寿命（此处为 "
"%(freshness_lifetime)s）时，该响应即被视为陈旧。\n"
"\n"
"缓存可能提供陈旧响应的原因有几种：\n"
"\n"
"* HTTP 允许在特殊情况下使用陈旧响应来满足请求；例如，当与源服务器失去联系时。这需要满足一些要求。\n"
"* `stale-if-error` 和 `stale-while-revalidate` 等响应指令明确允许在特定情况下使用陈旧响应。\n"
"* 一些缓存被配置为忽略响应的新鲜度指令。"

#: httplint/cache.py:489
msgid "This response allows caches to assign their own freshness lifetimes to it."
msgstr "此响应允许缓存为其分配自己的新鲜度寿命。"

#: httplint/cache.py:492
msgid ""
"When a response doesn't have explicit freshness information (like a "
"`Cache-Control: max-age`\n"
"directive, or `Expires` header), caches are allowed to estimate how fresh"
" it is using a heuristic\n"
"(provided that the status code allows it).\n"
"\n"
"Caches often do this using the `Last-Modified` header. For example, if a "
"response was last modified a\n"
"week ago, a cache might consider it fresh for a day.\n"
"\n"
"Consider adding a `Cache-Control: max-age` header; otherwise, it may be "
"cached for longer or shorter\n"
"than you'd like."
msgstr ""
"当响应没有显式的 freshness 信息时（例如 `Cache-Control: max-age` 指令或 `Expires` "
"头部），缓存可以根据启发式方法估算其 freshness（前提是状态码允许）。\n"
"\n"
"缓存通常使用 `Last-Modified` 头部来完成此操作。例如，如果一个响应在过去一周被修改过，缓存可能会认为它一天内是 fresh 的。\n"
"\n"
"请考虑添加 `Cache-Control: max-age` 头部；否则，它可能会被缓存比您期望的时间更长或更短。"

#: httplint/cache.py:507
msgid "This response cannot be considered fresh by caches."
msgstr "此响应无法被缓存视为新鲜。"

#: httplint/cache.py:508
msgid ""
"This response doesn't have explicit freshness information (like a ` "
"Cache-Control: max-age`\n"
"directive, or `Expires` header), and this status code doesn't allow "
"caches to calculate their own.\n"
"\n"
"Additionally, its status code doesn't allow caches to assign their own "
"freshness lifetimes to it.\n"
"\n"
"Therefore, while caches might be allowed to store it, they generally "
"can't use it, unless it can be\n"
"served stale.\n"
"\n"
"As a result, many caches will not store the response at all, because it "
"is not generally useful to do\n"
"so."
msgstr ""
"此响应没有明确的新鲜度信息（如 `Cache-Control: max-age` 指令或 `Expires` "
"标头），且此状态码不允许缓存自行计算。\n"
"\n"
"此外，其状态码也不允许缓存为其分配自己的新鲜度生命周期。\n"
"\n"
"因此，虽然缓存可能允许存储它，但通常不能使用它，除非它可以被提供为陈旧内容。\n"
"\n"
"结果是，许多缓存根本不会存储此响应，因为这样做通常没有用。"

#: httplint/cache.py:524
msgid "In exceptional circumstances, caches can serve this response stale."
msgstr "在特殊情况下，缓存可以提供此陈旧响应。"

#: httplint/cache.py:525
msgid ""
"HTTP allows stale responses to be served in some circumstances; for "
"example, if the origin\n"
"server can't be contacted, a stale response can be used even if it "
"doesn't have explicit freshness\n"
"information available.\n"
"\n"
"This behaviour can be prevented by using the `Cache-Control: must-"
"revalidate` response directive."
msgstr ""
"HTTP 在某些情况下允许提供过时的响应；例如，如果无法联系源服务器，即使过时的响应没有明确的有效性信息，也可以使用它。\n"
"\n"
"可以通过使用 `Cache-Control: must-revalidate` 响应指令来阻止此行为。"

#: httplint/cache.py:536
msgid "If an error occurs, caches can serve this response stale."
msgstr "如果发生错误，缓存可以提供此过时响应。"

#: httplint/cache.py:537
msgid ""
"The `stale-if-error` cache directive allows a cache to return a stale "
"response when an error\n"
"(e.g., a 500 Internal Server Error, or a network timeout) is encountered "
"while attempting to\n"
"revalidate it.\n"
"\n"
"See [RFC 5861](https://www.rfc-editor.org/rfc/rfc5861) for more "
"information."
msgstr ""
"`stale-if-error` 缓存指令允许缓存返回一个过时的响应，当在尝试重新验证时遇到错误（例如，500 内部服务器错误或网络超时）。\n"
"\n"
"有关更多信息，请参阅 [RFC 5861](https://www.rfc-editor.org/rfc/rfc5861)。"

#: httplint/cache.py:548
msgid ""
"This response can be served stale from a cache while it is being "
"revalidated."
msgstr "此响应在重新验证时可被陈旧缓存提供。"

#: httplint/cache.py:551
msgid ""
"The `stale-while-revalidate` cache directive allows a cache to serve a "
"stale response while a\n"
"revalidation request is happening in the background.\n"
"\n"
"See [RFC 5861](https://www.rfc-editor.org/rfc/rfc5861) for more "
"information."
msgstr ""
"`stale-while-revalidate` 缓存指令允许缓存提供陈旧响应，同时在后台进行重新验证请求。\n"
"\n"
"有关更多信息，请参阅 [RFC 5861](https://www.rfc-editor.org/rfc/rfc5861)。"

#: httplint/cache.py:561
msgid "This response cannot be served by a cache once it becomes stale."
msgstr "一旦过期，此响应将无法被缓存提供。"

#: httplint/cache.py:562 httplint/cache.py:574
msgid ""
"The `Cache-Control: must-revalidate` directive forbids caches from using "
"stale responses to satisfy\n"
"requests.\n"
"\n"
"For example, caches often use stale responses when they cannot connect to"
" the origin server; when\n"
"this directive is present, they will return an error rather than a stale "
"response."
msgstr ""
"`Cache-Control: must-revalidate` 指令禁止缓存使用过期的响应来满足请求。\n"
"\n"
"例如，当缓存无法连接到源服务器时，它们通常会使用过期的响应；当存在此指令时，它们将返回错误而不是过期的响应。"

#: httplint/cache.py:573
msgid "This response cannot be served by a cache now that it is stale."
msgstr "此响应已过期，无法由缓存提供服务。"

#: httplint/cache.py:585
msgid "This response cannot be served by a shared cache once it becomes stale."
msgstr "此响应在过时后无法通过共享缓存提供服务。"

#: httplint/cache.py:586 httplint/cache.py:600
msgid ""
"The presence of the `Cache-Control: proxy-revalidate` and/or `s-maxage` "
"directives forbids shared\n"
"caches (e.g., proxy caches) from using stale responses to satisfy "
"requests.\n"
"\n"
"For example, caches often use stale responses when they cannot connect to"
" the origin server; when\n"
"this directive is present, they will return an error rather than a stale "
"response.\n"
"\n"
"These directives do not affect private caches; for example, those in "
"browsers."
msgstr ""
"`Cache-Control: proxy-revalidate` 和/或 `s-maxage` "
"指令的存在禁止共享缓存（例如，代理缓存）使用过时的响应来满足请求。\n"
"\n"
"例如，当缓存无法连接到源服务器时，它们通常会使用过时的响应；当此指令存在时，它们将返回错误而不是过时的响应。\n"
"\n"
"这些指令不会影响私有缓存；例如，浏览器中的缓存。"

#: httplint/cache.py:599
msgid "This response cannot be served by a shared cache now that it is stale."
msgstr "此响应已过期，现在无法由共享缓存提供服务。"

#: httplint/cache.py:613
msgid "Cache-Control: max-age and Expires are both present."
msgstr "Cache-Control：同时存在 max-age 和 Expires。"

#: httplint/cache.py:614
msgid ""
"The `Cache-Control: max-age` directive and the `Expires` header are both "
"present.\n"
"\n"
"`max-age` takes precedence over `Expires`, so `Expires` is redundant and "
"can be removed."
msgstr ""
"`Cache-Control: max-age` 指令和 `Expires` 标头同时存在。\n"
"\n"
"`max-age` 优先于 `Expires`，因此 `Expires` 是多余的，可以移除。"

#: httplint/content_encoding.py:136
msgid "This message was compressed, but the GZIP header wasn't valid."
msgstr "此消息已压缩，但 GZIP 标头无效。"

#: httplint/content_encoding.py:138
#, python-format
msgid ""
"GZip-compressed responses have a header that contains metadata. Here, "
"that header wasn't valid;\n"
"the error encountered was \"`%(gzip_error)s`\"."
msgstr "GZip 压缩的响应包含一个包含元数据的头部。此处，该头部无效；遇到的错误是“%(gzip_error)s””。"

#: httplint/content_encoding.py:146
msgid "This message was compressed using GZip, but the data was corrupt."
msgstr "该消息使用 GZip 进行了压缩，但数据已损坏。"

#: httplint/content_encoding.py:147
#, python-format
msgid ""
"GZip-compressed responses use zlib compression to reduce the number of "
"bytes transferred on the\n"
"wire. However, this response could not be decompressed; the error "
"encountered was\n"
"\"`%(zlib_error)s`\".\n"
"\n"
"%(ok_zlib_len)s bytes were decompressed successfully before this; the "
"erroneous chunk starts with (in hex):\n"
"\n"
"    %(chunk_sample)s\n"
msgstr ""
"GZip 压缩的响应使用 zlib 压缩来减少传输的字节数。但是，此响应未能解压缩；遇到的错误是：“%(zlib_error)s”\n"
"\n"
"%(ok_zlib_len)s 字节已成功解压缩；错误块以十六进制开头：\n"
"\n"
"    %(chunk_sample)s"

#: httplint/content_type.py:15
msgid "The content doesn't match the declared Content-Type."
msgstr "内容与声明的 Content-Type 不符。"

#: httplint/content_type.py:16
#, python-format
msgid ""
"The `Content-Type` header declares the content as `%(declared_type)s`, "
"but it looks like\n"
"`%(sniffed_type)s`."
msgstr "`Content-Type` 标头声明内容为 `%(declared_type)s`，但实际内容看起来是 `%(sniffed_type)s`。"

#: httplint/message.py:240
msgid "The Content-Length header is correct."
msgstr "Content-Length 头是正确的。"

#: httplint/message.py:241
msgid ""
"`Content-Length` is used by HTTP to delimit messages; that is, to mark "
"the end of one message and\n"
"the beginning of the next."
msgstr "`Content-Length` 用于 HTTP 来分隔消息；也就是说，它标志着一条消息的结束和下一条消息的开始。"

#: httplint/message.py:249
msgid "The Content-Length header is incorrect."
msgstr "Content-Length 标头不正确。"

#: httplint/message.py:250
#, python-format
msgid ""
"`Content-Length` is used by HTTP to delimit messages; that is, to mark "
"the end of one message and\n"
"the beginning of the next. An incorrect `Content-Length` can cause "
"security and interoperability\n"
"issues.\n"
"\n"
"The actual content size was %(content_length)s bytes."
msgstr ""
"`Content-Length` 用于 HTTP 分隔消息；也就是说，标记一个消息的结束和下一个消息的开始。不正确的 `Content-"
"Length` 可能导致安全和互操作性问题。\n"
"\n"
"实际内容大小为 %(content_length)s 字节。"

#: httplint/message.py:261
#, python-format
msgid "The URI is very long (%(uri_len)s characters)."
msgstr "URI 非常长（%(uri_len)s 个字符）。"

#: httplint/message.py:262
msgid ""
"Long URIs aren't supported by some implementations, including proxies. A "
"reasonable upper size\n"
"limit is 8192 characters."
msgstr "长 URI 不被某些实现（包括代理）支持。一个合理的上限是 8192 个字符。"

#: httplint/message.py:270
msgid "The URI's syntax isn't valid."
msgstr "URI 的语法无效。"

#: httplint/message.py:271
msgid ""
"This isn't a valid URI. See\n"
"[RFC3986](http://www.ietf.org/rfc/rfc3986.txt) for more information."
msgstr "这不是一个有效的 URI。更多信息请参阅 [RFC3986](http://www.ietf.org/rfc/rfc3986.txt)。"

#: httplint/message.py:279
msgid "The status code is not an integer."
msgstr "状态码不是整数。"

#: httplint/message.py:280
msgid "This isn't a valid status code; it needs to be an ASCII integer."
msgstr "这并非一个有效的状态码；它需要是一个 ASCII 整数。"

#: httplint/message.py:287
msgid "The status phrase contains non-ASCII characters."
msgstr "状态短语包含非 ASCII 字符。"

#: httplint/message.py:288
msgid "The status phrase can only contain ASCII characters."
msgstr "状态短语只能包含 ASCII 字符。"

#: httplint/message.py:30
msgid "message"
msgstr "消息"

#: httplint/message.py:150
msgid "request"
msgstr "请求"

#: httplint/message.py:194
msgid "response"
msgstr "响应"

#: httplint/note.py:15
msgid "General"
msgstr "通用"

#: httplint/note.py:16
msgid "Browser Security"
msgstr "浏览器安全"

#: httplint/note.py:17
msgid "Content Negotiation"
msgstr "内容协商"

#: httplint/note.py:18
msgid "Caching"
msgstr "缓存"

#: httplint/note.py:19
msgid "Validation"
msgstr "验证"

#: httplint/note.py:20
msgid "Connection"
msgstr "连接"

#: httplint/note.py:21
msgid "Partial Content"
msgstr "部分内容"

#: httplint/status.py:301
msgid "304 (Not Modified) responses need to have a Date header."
msgstr "304 (未修改) 响应需要包含 Date 报头。"

#: httplint/status.py:302
msgid ""
"HTTP requires `304 (Not Modified)` responses to have a `Date` header in "
"all but the most unusual\n"
"circumstances."
msgstr "HTTP 要求 `304 (Not Modified)` 响应在大多数非极端情况下都必须包含 `Date` 报头。"

#: httplint/status.py:310
msgid "This 304 (Not Modified) response contains headers that should not be sent."
msgstr "此 304 (未修改) 响应包含不应发送的标头。"

#: httplint/status.py:313
#, python-format
msgid ""
"These headers are representation metadata that should not be sent in a "
"304 response unless\n"
"they are being used to guide cache updates:\n"
"\n"
"%(headers)s\n"
"\n"
"See [RFC 9110 Section 15.4.5](https://www.rfc-"
"editor.org/rfc/rfc9110.html#section-15.4.5) for\n"
"more information."
msgstr ""
"这些标头是表示元数据，除非用于指导缓存更新，否则不应在 304 响应中发送：\n"
"\n"
"%(headers)s\n"
"\n"
"有关更多信息，请参阅 [RFC 9110 Section 15.4.5](https://www.rfc-"
"editor.org/rfc/rfc9110.html#section-15.4.5)。"

#: httplint/status.py:326
msgid "A 100 (Continue) response was sent when it wasn't asked for."
msgstr "发送了不必要的 100 (Continue) 响应。"

#: httplint/status.py:327
msgid ""
"HTTP allows clients to ask a server if a request containing content "
"(e.g., uploading a large file)\n"
"will succeed before sending it, using a mechanism called "
"\"Expect/continue\".\n"
"\n"
"When used, the client sends an `Expect: 100-continue`, in the request "
"headers, and if the server is\n"
"willing to process it, it will send a `100 (Continue)` status code to "
"indicate that the request\n"
"should continue.\n"
"\n"
"This response has a `100 (Continue)` status code, but the request did not"
" ask for it using the\n"
"`Expect` request header. Sending this status code without it being "
"requested can cause\n"
"interoperability problems."
msgstr ""
"HTTP "
"允许客户端在发送包含内容的请求（例如上传大文件）之前，先询问服务器该请求是否会成功，这通过一种称为“Expect/continue”的机制来实现。"
"\n"
"\n"
"使用时，客户端会在请求头中发送 `Expect: 100-continue`，如果服务器愿意处理该请求，它会发送一个 `100 "
"(Continue)` 状态码，表示请求应继续。\n"
"\n"
"此响应具有 `100 (Continue)` 状态码，但请求未使用 `Expect` "
"请求头进行此要求。在未被要求的情况下发送此状态码可能会导致互操作性问题。"

#: httplint/status.py:343
msgid "The protocol was upgraded without being requested."
msgstr "协议在未被请求的情况下被升级。"

#: httplint/status.py:344
msgid ""
"HTTP defines the `Upgrade` header as a means of negotiating a change of "
"protocol; i.e., it\n"
"allows you to switch the protocol on a given connection from HTTP to "
"something else.\n"
"\n"
"This response was upgraded, but the request did not contain an `Upgrade` "
"header field.\n"
msgstr ""
"HTTP 将 `Upgrade` 标头定义为协商协议更改的一种方式；即，它允许您将给定连接上的协议从 HTTP 切换到其他协议。\n"
"\n"
"此响应已升级，但请求中不包含 `Upgrade` 标头字段。"

#: httplint/status.py:355
msgid "A new resource was created in response to a safe request."
msgstr "已根据安全请求创建了新资源。"

#: httplint/status.py:356
#, python-format
msgid ""
"The `201 (Created)` status code indicates that the request created a new "
"resource.\n"
"\n"
"However, the request method used (%(method)s) is defined as a \"safe\" "
"method; that is, it\n"
"should not have any side effects.\n"
"\n"
"Creating resources as a side effect of a safe method can have unintended "
"consequences; for example,\n"
"search engine spiders and similar automated agents often follow links, "
"and intermediaries sometimes\n"
"re-try safe methods when they fail."
msgstr ""
"`201 (Created)` 状态码表示请求创建了一个新资源。\n"
"\n"
"然而，使用的请求方法 `%(method)s` 被定义为“安全”方法；也就是说，它不应该产生任何副作用。\n"
"\n"
"创建资源作为安全方法的副作用可能会产生意想不到的后果；例如，搜索引擎爬虫和类似的自动化代理经常会跟踪链接，而中间件有时会在安全方法失败时重试。"

#: httplint/status.py:370
msgid "A new resource was created without its location being sent."
msgstr "新资源创建时未发送其位置。"

#: httplint/status.py:371
msgid ""
"The `201 (Created)` status code indicates that the request created a new "
"resource.\n"
"\n"
"HTTP specifies that the URL of the new resource is to be indicated in the"
" `Location` header,\n"
"but it isn't present in this response."
msgstr ""
"`201 (Created)` 状态码表示请求创建了一个新资源。\n"
"\n"
"HTTP 规定新资源的 URL 应在 `Location` 头部中指明，但在此响应中并未找到。"

#: httplint/status.py:381
msgid "This response is partial, but doesn't have a Content-Range header."
msgstr "此响应是部分的，但没有 Content-Range 标头。"

#: httplint/status.py:382
msgid ""
"The `206 (Partial Response)` status code indicates that the response "
"content is only partial.\n"
"\n"
"However, for a response to be partial, it needs to have a `Content-Range`"
" header to indicate\n"
"what part of the full response it carries. This response does not have "
"one."
msgstr ""
"`206 (Partial Response)` 状态码表示响应内容仅为部分内容。\n"
"\n"
"但是，要使响应成为部分响应，它需要包含 `Content-Range` 报头来指示其携带的是完整响应的哪一部分。此响应缺少该报头。"

#: httplint/status.py:392
msgid "A partial response was sent when it wasn't requested."
msgstr "发送了部分响应，但并未请求。"

#: httplint/status.py:393
msgid ""
"The `206 (Partial Response)` status code indicates that the response "
"content is only partial.\n"
"\n"
"However, the client needs to ask for it with the `Range` header, and the "
"request did not\n"
"include one."
msgstr ""
"`206 (Partial Response)` 状态码表示响应内容仅为部分内容。\n"
"\n"
"然而，客户端需要使用 `Range` 标头来请求它，而请求中未包含该标头。"

#: httplint/status.py:403
msgid "Redirects need to have a Location header."
msgstr "重定向需要有 Location 头。"

#: httplint/status.py:404
#, python-format
msgid ""
"The %(status)s status code redirects users to another URI. The `Location`"
" header is used to\n"
"convey this URI, but a valid one isn't present in this response."
msgstr ""
"%(status)s 状态码会将用户重定向到另一个 URI。`Location` 标头用于\n"
"传达此 URI，但此响应中没有有效的 URI。"

#: httplint/status.py:412
#, python-format
msgid "The %(status)s status code is deprecated."
msgstr "%(status)s 状态码已被弃用。"

#: httplint/status.py:413
msgid ""
"When a status code is deprecated, it should not be used, because its "
"meaning is not well-defined\n"
"enough to ensure interoperability."
msgstr "当状态码被弃用时，不应使用，因为其含义没有得到充分定义，无法确保互操作性。"

#: httplint/status.py:421
#, python-format
msgid "The %(status)s status code is reserved."
msgstr "%(status)s 状态码是保留的。"

#: httplint/status.py:422
msgid ""
"Reserved status codes can only be used by future, standard protocol "
"extensions; they are not for\n"
"private use."
msgstr "保留状态码只能由未来的标准协议扩展使用，不能用于私人用途。"

#: httplint/status.py:430
#, python-format
msgid "%(status)s is not a standard HTTP status code."
msgstr "%(status)s 不是标准的 HTTP 状态码。"

#: httplint/status.py:431
msgid ""
"Non-standard status codes are not well-defined and interoperable. Instead"
" of defining your own\n"
"status code, you should reuse one of the more generic ones; for example, "
"`400` for a client-side\n"
"problem, or `500` for a server-side problem."
msgstr "非标准状态码定义不清且互操作性差。你不应定义自己的状态码，而应重用更通用的状态码；例如，客户端问题使用 `400`，服务器端问题使用 `500`。"

#: httplint/status.py:440
msgid "The server didn't understand the request."
msgstr "服务器不理解请求。"

#: httplint/status.py:448
msgid "The server has forbidden this request."
msgstr "服务器已禁止此请求。"

#: httplint/status.py:456 httplint/status.py:464
msgid "The resource could not be found."
msgstr "找不到该资源。"

#: httplint/status.py:457
msgid "The server couldn't find any resource to serve for the given URI."
msgstr "服务器未能找到任何可用于所提供 URI 的资源。"

#: httplint/status.py:472
msgid "The request conflicted with the state of the resource."
msgstr "请求与资源的当前状态冲突。"

#: httplint/status.py:480
msgid "The resource is gone."
msgstr "资源已丢失。"

#: httplint/status.py:481
msgid ""
"The server previously had a resource at the given URI, but it is no "
"longer there."
msgstr "服务器之前在该 URI 下存在一个资源，但现在已不存在。"

#: httplint/status.py:488
msgid "The request content was too large for the server."
msgstr "服务器无法处理过大的请求内容。"

#: httplint/status.py:489
msgid ""
"The server rejected the request because the request content sent was too "
"large."
msgstr "服务器拒绝了请求，因为发送的请求内容过大。"

#: httplint/status.py:496
#, python-format
msgid "The server won't accept a URI this long %(uri_len)s."
msgstr "服务器不接受这么长的 URI %(uri_len)s。"

#: httplint/status.py:497
#, python-format
msgid ""
"The %(status)s status code means that the server can't or won't accept a "
"request-uri this long."
msgstr "%(status)s 状态码表示服务器无法或不愿意接受如此长的请求 URI。"

#: httplint/status.py:504
msgid "The resource doesn't support this media type in requests."
msgstr "资源不支持请求中的此媒体类型。"

#: httplint/status.py:512
msgid "The server returned 418 (I'm a Teapot), an easter egg defined in RFC 2324."
msgstr "服务器返回 418 (I'm a Teapot)，这是 RFC 2324 中定义的彩蛋。"

#: httplint/status.py:515
msgid ""
"RFC 2324 was an April Fools' Day RFC that lampooned the various ways HTTP"
" was abused; one such abuse\n"
"was the definition of the application-specific `418 (I'm a Teapot)` "
"status code. In the\n"
"intervening years, this status code has been sometimes implemented as an "
"\"easter egg\".\n"
"\n"
"This status code is not a part of HTTP and hence it might not be "
"supported by some strict\n"
"standards-compliant clients.\n"
msgstr ""
"RFC 2324 是一个愚人节 RFC，它讽刺了 HTTP 的各种滥用方式；其中一种滥用就是定义了应用程序特定的 `418 (I'm a "
"Teapot)` 状态码。在随后的几年里，这个状态码有时被用作“复活节彩蛋”。\n"
"\n"
"此状态码不是 HTTP 的一部分，因此一些严格遵循标准的客户端可能不支持。"

#: httplint/status.py:528
msgid "There was a general server error."
msgstr "发生了一般性服务器错误。"

#: httplint/status.py:536
msgid "The server doesn't implement the request method."
msgstr "服务器未实现请求方法。"

#: httplint/status.py:544
msgid "An intermediary encountered an error."
msgstr "中间人遇到错误。"

#: httplint/status.py:552
msgid "The server is temporarily unavailable."
msgstr "服务器暂时不可用。"

#: httplint/status.py:560
msgid "An intermediary timed out."
msgstr "中间人超时。"

#: httplint/status.py:568
msgid "The request HTTP version isn't supported."
msgstr "请求的 HTTP 版本不受支持。"

#: httplint/status.py:576
msgid "The request didn't have any preconditions."
msgstr "请求没有任何前提条件。"

#: httplint/status.py:577
msgid ""
"The `412 (Precondition Failed)` status code indicates that one or more "
"conditions given in the\n"
"request header fields evaluated to false when tested on the server.\n"
"\n"
"However, this request didn't contain any conditional headers (such as "
"`If-Match`, `If-None-Match`,\n"
"`If-Modified-Since`, `If-Unmodified-Since`, or `If-Range`)."
msgstr ""
"`412 (Precondition Failed)` 状态码表示在请求头字段中提供的一个或多个条件在服务器上测试时评估为 false。\n"
"\n"
"但是，此请求不包含任何条件头（例如 `If-Match`、`If-None-Match`、`If-Modified-Since`、`If-"
"Unmodified-Since` 或 `If-Range`）。"

#: httplint/status.py:588
msgid "The request didn't have a Range header."
msgstr "请求没有 Range 头部。"

#: httplint/status.py:589
msgid ""
"The `416 (Range Not Satisfiable)` status code indicates that the set of "
"ranges in the request's\n"
"`Range` header field overlap the current extent of the selected resource."
"\n"
"\n"
"However, this request didn't contain a `Range` header."
msgstr ""
"`416 (Range Not Satisfiable)` 状态码表示请求的 `Range` 头部字段中的范围集与所选资源的当前范围重叠。\n"
"\n"
"然而，此请求不包含 `Range` 头部。"

#: httplint/status.py:599
msgid "The request didn't have an Expect header."
msgstr "请求没有 `Expect` 头部。"

#: httplint/status.py:600
msgid ""
"The `417 (Expectation Failed)` status code indicates that the expectation"
" given in the request's\n"
"`Expect` header field could not be met by at least one of the inbound "
"servers.\n"
"\n"
"However, this request didn't contain an `Expect` header."
msgstr ""
"`417 (Expectation Failed)` 状态码表示请求中的 `Expect` 头部字段所期望的内容，至少有一台入站服务器无法满足。\n"
"\n"
"然而，此请求并未包含 `Expect` 头部。"

#: httplint/status.py:610
msgid "The server couldn't meet the 100-continue expectation."
msgstr "服务器未能满足 100-continue 预期。"

#: httplint/status.py:611
msgid ""
"The `417 (Expectation Failed)` status code indicates that the expectation"
" given in the request's\n"
"`Expect` header field could not be met by at least one of the inbound "
"servers.\n"
"\n"
"In this case, the client requested `100-continue`, but the server (or an "
"intermediary) couldn't\n"
"satisfy it."
msgstr ""
"`417 (Expectation Failed)` 状态码表示请求的 `Expect` 标头字段中给出的期望未能被至少一个入站服务器满足。\n"
"\n"
"在这种情况下，客户端请求了 `100-continue`，但服务器（或中间服务器）无法满足该请求。"

#: httplint/status.py:622
msgid "The server sent early hints."
msgstr "服务器发送了早期提示。"

#: httplint/status.py:623
msgid ""
"The `103 (Early Hints)` status code allows the server to send some "
"headers before the final response,\n"
"typically to help the client start fetching resources earlier."
msgstr ""
"`103 (Early Hints)` 状态码允许服务器在最终响应之前发送一些标头，\n"
"通常是为了帮助客户端更早地开始获取资源。"

#: httplint/status.py:631
msgid "The server supports upload resumption."
msgstr "服务器支持上传续传。"

#: httplint/status.py:632
msgid ""
"The `104 (Upload Resumption Supported)` status code indicates that the "
"server supports resumable\n"
"uploads."
msgstr "`104 (Upload Resumption Supported)` 状态码表示服务器支持可恢复的上传。"

#: httplint/status.py:640
msgid "The members of a DAV binding have already been enumerated."
msgstr "DAV 绑定成员已枚举。"

#: httplint/status.py:641
msgid ""
"The `208 (Already Reported)` status code can be used inside a DAV: "
"propstat response element to\n"
"avoid enumerating the internal members of multiple bindings to the same "
"collection repeatedly."
msgstr "`208 (Already Reported)` 状态码可以在 DAV: propstat 响应元素中使用，以避免重复枚举绑定到同一集合的内部成员。"

#: httplint/status.py:649
msgid ""
"The request was directed at a server that is not able to produce a "
"response."
msgstr "请求被导向了一个无法响应的服务器。"

#: httplint/status.py:652
msgid ""
"The `421 (Misdirected Request)` status code indicates that the request "
"was directed at a server\n"
"that is not able to produce a response. This can happen when a connection"
" is reused."
msgstr "`421 (Misdirected Request)` 状态码表示请求被定向到一个无法生成响应的服务器。当连接被重用时，可能会发生这种情况。"

#: httplint/status.py:660
msgid ""
"The server is unwilling to risk processing a request that might be "
"replayed."
msgstr "服务器不愿冒处理可能被重放的请求的风险。"

#: httplint/status.py:663
msgid ""
"The `425 (Too Early)` status code indicates that the server is unwilling "
"to risk processing a\n"
"request that might be replayed."
msgstr "`425 (Too Early)` 状态码表示服务器不愿冒险处理可能被重放的请求。"

#: httplint/status.py:671
msgid "The origin server requires the request to be conditional."
msgstr "源服务器要求请求是有条件的。"

#: httplint/status.py:672
msgid ""
"The `428 (Precondition Required)` status code indicates that the origin "
"server requires the request\n"
"to be conditional."
msgstr "`428 (Precondition Required)` 状态码表示源服务器要求请求必须是有条件的。"

#: httplint/status.py:680
msgid "The client has sent too many requests in a given amount of time."
msgstr "客户端在给定时间内发送的请求过多。"

#: httplint/status.py:681
msgid ""
"The `429 (Too Many Requests)` status code indicates that the client has "
"sent too many requests in a\n"
"given amount of time (\"rate limiting\")."
msgstr "`429 (Too Many Requests)` 状态码表示客户端在给定时间内发送了过多的请求（“速率限制”）。"

#: httplint/status.py:689
msgid ""
"The server is unwilling to process the request because its headers are "
"too large."
msgstr "服务器不愿处理请求，因为其头部过大。"

#: httplint/status.py:690
msgid ""
"The `431 (Request Header Fields Too Large)` status code indicates that "
"the server is unwilling to\n"
"process the request because its header fields are too large."
msgstr "`431 (Request Header Fields Too Large)` 状态码表示服务器不愿意处理该请求，因为其请求头字段过大。"

#: httplint/status.py:698
msgid "The resource is unavailable for legal reasons."
msgstr "该资源因法律原因不可用。"

#: httplint/status.py:699
msgid ""
"The `451 (Unavailable For Legal Reasons)` status code indicates that the "
"server is denying access to\n"
"the resource as a consequence of a legal demand."
msgstr "`451 (Unavailable For Legal Reasons)` 状态码表示服务器因法律要求而拒绝访问该资源。"

#: httplint/status.py:707
msgid ""
"The server terminated an operation because it encountered an infinite "
"loop."
msgstr "服务器因遇到无限循环而终止了操作。"

#: httplint/status.py:710
msgid ""
"The `508 (Loop Detected)` status code indicates that the server "
"terminated an operation because it\n"
"encountered an infinite loop while processing a request with \"Depth: "
"infinity\"."
msgstr "`508 (Loop Detected)` 状态码表示服务器在处理带有“Depth: infinity”的请求时检测到无限循环，因此终止了该操作。"

#: httplint/status.py:718
msgid "The client needs to authenticate to gain network access."
msgstr "客户端需要进行身份验证才能获得网络访问权限。"

#: httplint/status.py:719
msgid ""
"The `511 (Network Authentication Required)` status code indicates that "
"the client needs to\n"
"authenticate to gain network access."
msgstr "`511 (网络认证要求)` 状态码表示客户端需要认证才能获得网络访问权限。"

#: httplint/util.py:81 test/test_i18n.py:10 test/test_i18n.py:15
#: test/test_i18n.py:18
msgid "ahead"
msgstr "提前"

#: httplint/util.py:83
msgid "behind"
msgstr "落后"

#: httplint/field/cors.py:56
#, python-format
msgid "The %(field_name)s header is only allowed in CORS preflight responses."
msgstr "“%(field_name)s” 头仅允许在 CORS 预检响应中使用。"

#: httplint/field/cors.py:57
#, python-format
msgid ""
"The `%(field_name)s` header is only used in the response to a Cross-"
"Origin Resource Sharing (CORS)\n"
"preflight request.\n"
"\n"
"A preflight request is an `OPTIONS` request that includes an `Origin` "
"header and an\n"
"`Access-Control-Request-Method` header.\n"
"\n"
"This response was not to a CORS preflight request, so this header should "
"not be present."
msgstr ""
"`%(field_name)s` 标头仅在对跨域资源共享 (CORS) 预检请求的响应中使用。\n"
"\n"
"预检请求是包含 `Origin` 标头和 `Access-Control-Request-Method` 标头的 `OPTIONS` 请求。\n"
"\n"
"此响应不是对 CORS 预检请求的响应，因此不应存在此标头。"

#: httplint/field/cors.py:70
#, python-format
msgid "The %(field_name)s header is only allowed in CORS preflight requests."
msgstr "%(field_name)s 标头仅在 CORS 预检请求中允许。"

#: httplint/field/cors.py:71
#, python-format
msgid ""
"The `%(field_name)s` header is only used in a Cross-Origin Resource "
"Sharing (CORS) preflight\n"
"request.\n"
"\n"
"A preflight request uses the `OPTIONS` method; this request uses "
"`%(method)s`."
msgstr ""
"`%(field_name)s` 标头仅在跨源资源共享 (CORS) 预检请求中使用。\n"
"\n"
"预检请求使用 `OPTIONS` 方法；此请求使用 `%(method)s`。"

#: httplint/field/cors.py:81
#, python-format
msgid "The %(field_name)s header requires the Origin header."
msgstr "%(field_name)s 标头需要 Origin 标头。"

#: httplint/field/cors.py:82
#, python-format
msgid ""
"The `%(field_name)s` header is only used in a Cross-Origin Resource "
"Sharing (CORS) preflight\n"
"request.\n"
"\n"
"A preflight request requires the `Origin` header to be present."
msgstr ""
"`%(field_name)s` 标头仅用于跨源资源共享 (CORS) 预检请求。\n"
"\n"
"预检请求要求存在 `Origin` 标头。"

#: httplint/field/cors.py:92
#, python-format
msgid ""
"The %(field_name)s header requires the Access-Control-Request-Method "
"header."
msgstr "%(field_name)s 标头要求 Access-Control-Request-Method 标头。"

#: httplint/field/cors.py:95
#, python-format
msgid ""
"The `%(field_name)s` header is only used in a Cross-Origin Resource "
"Sharing (CORS) preflight\n"
"request.\n"
"\n"
"A preflight request requires the `Access-Control-Request-Method` header "
"to be present."
msgstr ""
"`%(field_name)s` 标头仅在跨源资源共享 (CORS) 预检请求中使用。\n"
"\n"
"预检请求需要存在 `Access-Control-Request-Method` 标头。"

#: httplint/field/notes.py:11
#, python-format
msgid "Only one %(field_name)s field is allowed in a response's headers."
msgstr "响应头中只允许一个 %(field_name)s 字段。"

#: httplint/field/notes.py:12
msgid ""
"This field is designed to only occur once in a message. When it occurs "
"more than once, a receiver\n"
"needs to choose the one to use, which can lead to interoperability "
"problems, since different\n"
"implementations may make different choices."
msgstr "此字段设计为在消息中只出现一次。当它出现多次时，接收器需要选择使用哪一个，这可能导致互操作性问题，因为不同的实现可能会做出不同的选择。"

#: httplint/field/notes.py:21
#, python-format
msgid "\"%(field_name)s\" is not a valid field name."
msgstr "“%(field_name)s” 不是一个有效的字段名。"

#: httplint/field/notes.py:22
#, python-brace-format
msgid ""
"Field names are limited to the `token` production in HTTP; i.e., they "
"can't contain parenthesis,\n"
"angle brackets (<>), ampersands (@), commas, semicolons, colons, "
"backslashes (\\), forward\n"
"slashes (/), quotes, square brackets ([]), question marks, equals signs "
"(=), curly brackets ({})\n"
"spaces or tabs."
msgstr ""
"字段名称受限于 HTTP 的 `token` 规则；即，它们不能包含括号、\n"
"尖括号 (<>)、与号 (@)、逗号、分号、冒号、反斜杠 (\\)、正斜杠 (/)、引号、方括号 ([])、\n"
"问号、等号 (=)、花括号 ({})、空格或制表符。"

#: httplint/field/notes.py:32
#, python-format
msgid "The %(field_name)s field value isn't valid."
msgstr "%(field_name)s 字段的值无效。"

#: httplint/field/notes.py:33
#, python-format
msgid ""
"The value for this field doesn't conform to its specified syntax; see "
"[its\n"
"definition](%(ref_uri)s) for more information."
msgstr "此字段的值不符合其指定的语法；请参阅[其定义](%(ref_uri)s)以获取更多信息。"

#: httplint/field/notes.py:41
#, python-format
msgid "The %(field_name)s field value isn't a valid Structured Field."
msgstr "%(field_name)s 字段的值不是有效的结构化字段。"

#: httplint/field/notes.py:42
#, python-format
msgid ""
"The %(field_name)s field is defined as a\n"
"[Structured Field](https://www.rfc-editor.org/rfc/rfc9651.html),\n"
"but its value can't be parsed as one. As a result, this field is likely\n"
"to be ignored.\n"
"\n"
"The parser reports this error:\n"
"    %(error)s."
msgstr ""
"字段 %(field_name)s 定义为\n"
"[结构化字段](https://www.rfc-editor.org/rfc/rfc9651.html)，\n"
"但其值无法解析为结构化字段。因此，该字段很可能\n"
"被忽略。\n"
"\n"
"解析器报告此错误：\n"
"    %(error)s。"

#: httplint/field/notes.py:55
#, python-format
msgid "The '%(param)s' parameter's value cannot be quoted."
msgstr "“%(param)s” 参数的值不能被引用。"

#: httplint/field/notes.py:56
#, python-format
msgid ""
"Parameter values that end in '*' have a specific format, defined in\n"
"[RFC5987](https://www.rfc-editor.org/rfc/rfc5987), to allow non-ASCII "
"text.\n"
"\n"
"The `%(param)s` parameter on the `%(field_name)s` field has double-quotes"
" around it, which is not\n"
"valid."
msgstr ""
"以 '*' 结尾的参数值具有特定格式，定义在\n"
"[RFC5987](https://www.rfc-editor.org/rfc/rfc5987) 中，以允许使用非 ASCII 文本。\n"
"\n"
"`%(field_name)s` 字段上的 `%(param)s` 参数带有双引号，这是无效的。"

#: httplint/field/notes.py:67
#, python-format
msgid "The %(param)s parameter's value is invalid."
msgstr "%(param)s 参数的值无效。"

#: httplint/field/notes.py:68
#, python-format
msgid ""
"Parameter values that end in '*' have a specific format, defined in\n"
"[RFC5987](https://www.rfc-editor.org/rfc/rfc5987), to allow non-ASCII "
"text.\n"
"\n"
"The `%(param)s` parameter on the `%(field_name)s` field is not valid; it "
"needs to have three\n"
"parts, separated by single quotes (')."
msgstr ""
"结尾带有“*”的参数值具有特定格式，在\n"
"[RFC5987](https://www.rfc-editor.org/rfc/rfc5987) 中定义，允许使用非 ASCII 文本。\n"
"\n"
"`%(field_name)s` 字段上的 `%(param)s` 参数无效；它需要包含三个\n"
"部分，并用单引号（'）分隔。"

#: httplint/field/notes.py:79
#, python-format
msgid "The %(param)s* parameter isn't allowed on the %(field_name)s field."
msgstr "“%(param)s” 参数在 %(field_name)s 字段中不允许。"

#: httplint/field/notes.py:80
#, python-format
msgid ""
"Parameter values that end in '*' are reserved for non-ascii text, as "
"explained in\n"
"[RFC5987](https://www.rfc-editor.org/rfc/rfc5987).\n"
"\n"
"The `%(param)s` parameter on the `%(field_name)s` field does not allow "
"this; you should use\n"
"%(param)s without the \"*\" on the end (and without the associated "
"encoding)."
msgstr ""
"结尾带 '*' 的参数值保留给非 ASCII 文本，如\n"
"[RFC5987](https://www.rfc-editor.org/rfc/rfc5987) 中所述。\n"
"\n"
"`%(field_name)s` 字段上的 `%(param)s` 参数不允许这样做；您应该使用\n"
"没有结尾 '*' 的 %(param)s（并且不进行关联编码）。"

#: httplint/field/notes.py:91
#, python-format
msgid "The %(param)s parameter's value doesn't define an encoding."
msgstr "%(param)s 参数的值未定义编码。"

#: httplint/field/notes.py:92
#, python-format
msgid ""
"Parameter values that end in '*' have a specific format, defined in\n"
"[RFC5987](https://www.rfc-editor.org/rfc/rfc5987), to allow non-ASCII "
"text.\n"
"\n"
"The `%(param)s` parameter on the `%(field_name)s` header doesn't declare "
"its character encoding,\n"
"which means that recipients can't understand it. It should be `UTF-8`."
msgstr ""
"以 '*' 结尾的参数值采用特定格式，定义于\n"
"[RFC5987](https://www.rfc-editor.org/rfc/rfc5987)，允许使用非 ASCII 文本。\n"
"\n"
"`%(field_name)s` 标头上的 `%(param)s` 参数未声明其字符编码，\n"
"这意味着接收者无法理解它。它应该是 `UTF-8`。"

#: httplint/field/notes.py:103
#, python-format
msgid "The %(param)s parameter's value uses an encoding other than UTF-8."
msgstr "%(param)s 参数的值使用了 UTF-8 以外的编码。"

#: httplint/field/notes.py:104
#, python-format
msgid ""
"Parameter values that end in '*' have a specific format, defined in\n"
"[RFC5987](https://www.rfc-editor.org/rfc/rfc5987), to allow non-ASCII "
"text.\n"
"\n"
"The `%(param)s` parameter on the `%(field_name)s` header uses the "
"`'%(enc)s` encoding, which has\n"
"interoperability issues with some browsers. It should be `UTF-8`."
msgstr ""
"以“*”结尾的参数值具有特定格式，在 [RFC5987](https://www.rfc-editor.org/rfc/rfc5987) "
"中定义，允许使用非 ASCII 文本。\n"
"\n"
"`%(field_name)s` 标头上的 `%(param)s` "
"参数使用了“`%(enc)s`”编码，该编码在与某些浏览器交互时存在问题。应使用 `UTF-8`。"

#: httplint/field/notes.py:115
#, python-format
msgid "The '%(param)s' parameter repeats in the %(field_name)s header."
msgstr "“%(param)s” 参数在 %(field_name)s 标头中重复。"

#: httplint/field/notes.py:116
#, python-format
msgid ""
"Parameters on the %(field_name)s field should not repeat; implementations"
" may handle them\n"
"differently."
msgstr "%(field_name)s 字段上的参数不应重复；实现可能对此有不同的处理方式。"

#: httplint/field/notes.py:124
#, python-format
msgid "The '%(param)s' parameter on the %(field_name)s header is single-quoted."
msgstr "'%(param)s' 参数在 %(field_name)s 标头中被单引号包围。"

#: httplint/field/notes.py:127
#, python-format
msgid ""
"The `%(param)s`'s value on the %(field_name)s field starts and ends with "
"a single quote (').\n"
"However, single quotes don't mean anything there.\n"
"\n"
"This means that the value will be interpreted as `%(param_val)s`, **not**"
"\n"
"`%(param_val_unquoted)s`. If you intend the latter, remove the single "
"quotes."
msgstr ""
"`%(param)s` 在 %(field_name)s 字段中的值以单引号 (') 开始和结束。\n"
"然而，单引号在那里没有任何意义。\n"
"\n"
"这意味着该值将被解释为 `%(param_val)s`，**而不是**\n"
"`%(param_val_unquoted)s`。如果您的意图是后者，请删除单引号。"

#: httplint/field/notes.py:138
#, python-format
msgid "The %(field_name)s header's value isn't a valid date."
msgstr "%(field_name)s 头的取值不是一个有效的日期。"

#: httplint/field/notes.py:139
msgid ""
"HTTP dates have specific syntax, and sending an invalid date can cause a "
"number of problems,\n"
"especially with caching. Common problems include sending \"1 May\" "
"instead of \"01 May\" (the month\n"
"is a fixed-width field), and sending a date in a timezone other than GMT."
"\n"
"\n"
"See [the HTTP specification](https://www.rfc-editor.org/rfc/rfc9110.html"
"#name-date-time-formats) for more\n"
"information."
msgstr ""
"HTTP 日期具有特定的语法，发送无效日期可能会导致一系列问题，尤其是在缓存方面。常见的问题包括发送“1 May”而不是“01 "
"May”（月份是固定宽度字段），以及发送除 GMT 之外的任何时区的日期。\n"
"\n"
"有关更多信息，请参阅 [HTTP 规范](https://www.rfc-editor.org/rfc/rfc9110.html#name-"
"date-time-formats)。"

#: httplint/field/notes.py:151
#, python-format
msgid "The %(field_name)s header's value uses an obsolete format."
msgstr "%(field_name)s 标头的值使用了过时的格式。"

#: httplint/field/notes.py:152
msgid ""
"HTTP has a number of defined date formats for historical reasons. This "
"header is using an old\n"
"format that are now obsolete. See [the\n"
"specification](https://www.rfc-editor.org/rfc/rfc9110.html#name-obsolete-"
"date-formats) for more information.\n"
msgstr ""
"HTTP 出于历史原因定义了多种日期格式。此标头使用的是现已废弃的旧格式。有关更多信息，请参阅 [规范](https://www.rfc-"
"editor.org/rfc/rfc9110.html#name-obsolete-date-formats)。"

#: httplint/field/notes.py:162 httplint/field/notes.py:170
#, python-format
msgid "\"%(field_name)s\" is a request header."
msgstr "\"%(field_name)s\" 是一个请求头。"

#: httplint/field/notes.py:163
#, python-format
msgid "The %(field_name)s field isn't defined to have any meaning in responses."
msgstr "“%(field_name)s”字段在响应中未定义任何含义。"

#: httplint/field/notes.py:171
#, python-format
msgid "The %(field_name)s field isn't defined to have any meaning in requests."
msgstr "“%(field_name)s” 字段在请求中未定义任何含义。"

#: httplint/field/notes.py:178
#, python-format
msgid "The %(field_name)s header is deprecated."
msgstr "%(field_name)s 标头已弃用。"

#: httplint/field/notes.py:179
#, python-format
msgid ""
"This field is no longer recommended for use, because of interoperability "
"problems and/or\n"
"lack of use.\n"
"\n"
"See [the deprecation notice](%(deprecation_ref)s) for more information."
msgstr ""
"此字段不再推荐使用，因为存在互操作性问题和/或未使用。\n"
"\n"
"有关更多信息，请参阅[弃用通知](%(deprecation_ref)s)。"

#: httplint/field/notes.py:189
msgid "The User-Agent header is missing."
msgstr "缺少 User-Agent 标头。"

#: httplint/field/notes.py:190
msgid ""
"Clients SHOULD send a `User-Agent` header field.\n"
"\n"
"See [RFC 9110 Section 10.1.5](https://www.rfc-"
"editor.org/rfc/rfc9110.html#section-10.1.5)\n"
"for details."
msgstr ""
"客户端应发送 `User-Agent` 标头字段。\n"
"\n"
"有关详情，请参阅 [RFC 9110 Section 10.1.5](https://www.rfc-"
"editor.org/rfc/rfc9110.html#section-10.1.5)。"

#: httplint/field/notes.py:200
#, python-format
msgid "In %(field_name)s, the %(context)s key '%(key)s' is duplicated."
msgstr "在 %(field_name)s 中，%(context)s 键 '%(key)s' 被重复了。"

#: httplint/field/notes.py:201
#, python-format
msgid ""
"The %(context)s key '%(key)s' is duplicated. All instances after the "
"first will be ignored."
msgstr "'%(context)s' 键 '%(key)s' 已重复。第一个实例之后的所有实例都将被忽略。"

#: httplint/field/section.py:97
#, python-format
msgid "The %(field_name)s header is very large (%(field_size)s bytes)."
msgstr "%(field_name)s 标头非常大（%(field_size)s 字节）。"

#: httplint/field/section.py:98
msgid "Some implementations limit the size of any single header line."
msgstr "某些实现会限制单个标头行的长度。"

#: httplint/field/section.py:105
#, python-format
msgid "The total size of the headers is very large (%(header_size)s bytes)."
msgstr "请求头总大小过大（%(header_size)s 字节）。"

#: httplint/field/section.py:106
msgid ""
"Some implementations limit the total size of the header block. 32KB is a "
"reasonable\n"
"upper limit."
msgstr "某些实现会限制请求头块的总大小。32KB 是一个合理的上限。"

#: httplint/field/section.py:114
#, python-format
msgid "The %(field_name)s header's name contains non-ASCII characters."
msgstr "%(field_name)s 报头字段的名称包含非 ASCII 字符。"

#: httplint/field/section.py:115
msgid "HTTP field names can only contain ASCII characters."
msgstr "HTTP 字段名称只能包含 ASCII 字符。"

#: httplint/field/section.py:122
#, python-format
msgid "The %(field_name)s header's value contains non-ASCII characters."
msgstr "“%(field_name)s” 标头的值包含非 ASCII 字符。"

#: httplint/field/section.py:123
msgid ""
"HTTP fields notionally use the ISO-8859-1 character set, but in most "
"cases are pure ASCII\n"
"(a subset of this encoding).\n"
"\n"
"This header has non-ASCII characters, which have been interpreted as "
"being encoded in\n"
"ISO-8859-1. If another encoding is used (e.g., UTF-8), the results may be"
" unpredictable."
msgstr ""
"HTTP 字段名义上使用 ISO-8859-1 字符集，但在大多数情况下是纯 ASCII\n"
"（此编码的子集）。\n"
"\n"
"此标头包含非 ASCII 字符，已被解释为使用\n"
"ISO-8859-1 编码。如果使用了其他编码（例如 UTF-8），结果可能会不可预测。"

#: httplint/field/unnecessary.py:51
#, python-format
msgid "The %(header_name)s header can probably be removed."
msgstr "%(header_name)s 标头可能可以移除。"

#: httplint/field/unnecessary.py:52
#, python-format
msgid ""
"The `%(header_name)s` header adds little value, contributes to "
"unnecessary bandwidth,\n"
"and may increase security risk by exposing details of the back-end "
"system.\n"
"\n"
"Consider removing it."
msgstr ""
"`%(header_name)s` 标头几乎没有价值，会增加不必要的带宽，\n"
"并且可能通过暴露后端系统的详细信息来增加安全风险。\n"
"\n"
"考虑移除它。"

#: httplint/field/parsers/accept_ranges.py:30
msgid "This response advertises support for non-standard range-units."
msgstr "此响应支持非标准范围单位。"

#: httplint/field/parsers/accept_ranges.py:31
msgid ""
"The `Accept-Ranges` response header tells clients what `range-unit`s a "
"resource is willing to\n"
"process in future requests. HTTP only defines two: `bytes` and `none`.\n"
"\n"
"Clients who don't know about the non-standard range-unit will not be able"
" to use it."
msgstr ""
"`Accept-Ranges` 响应头告知客户端资源愿意在未来请求中处理的 `range-unit`s。HTTP 仅定义两种：`bytes` 和 "
"`none`。\n"
"\n"
"不了解非标准 `range-unit` 的客户端将无法使用它。"

#: httplint/field/parsers/access_control_allow_credentials.py:29
msgid "Access-Control-Allow-Credentials must be 'true'."
msgstr "Access-Control-Allow-Credentials 必须是 'true'。"

#: httplint/field/parsers/access_control_allow_credentials.py:30
msgid ""
"The `Access-Control-Allow-Credentials` header must be set to `true` if "
"present. If you don't want\n"
"to allow credentials, omit the header."
msgstr ""
"如果存在 `Access-Control-Allow-Credentials` 标头，则必须将其设置为 "
"`true`。如果您不想允许凭据，请省略该标头。"

#: httplint/field/parsers/access_control_allow_origin.py:30
msgid "Access-Control-Allow-Origin should not have multiple values."
msgstr "Access-Control-Allow-Origin 不应有多个值。"

#: httplint/field/parsers/access_control_allow_origin.py:31
msgid ""
"The `Access-Control-Allow-Origin` header can only contain a single "
"origin, `*`, or `null`. It\n"
"cannot contain a list of origins."
msgstr "`Access-Control-Allow-Origin` 标头只能包含单个来源、`*` 或 `null`。它不能包含来源列表。"

#: httplint/field/parsers/age.py:38
msgid "The Age header's value should be an integer."
msgstr "Age 头部的取值应为整数。"

#: httplint/field/parsers/age.py:39
msgid ""
"The `Age` header indicates the age of the response; i.e., how long it has"
" been cached\n"
"since it was generated. The value given was not an integer, so it is not "
"a valid age."
msgstr "`Age` 标头指示响应的年龄；即，自生成以来缓存了多长时间。给定值不是整数，因此不是有效的年龄。"

#: httplint/field/parsers/age.py:47
msgid "The Age headers' value must be a positive integer."
msgstr "Age 标头的值必须是正整数。"

#: httplint/field/parsers/age.py:48
msgid ""
"The `Age` header indicates the age of the response; i.e., how long it has"
" been cached\n"
"since it was generated. The value given was negative, so it is not a "
"valid age."
msgstr "`Age` 标头指示响应的年龄；即，自生成以来缓存了多长时间。给出的值是负数，因此不是有效的年龄。"

#: httplint/field/parsers/age.py:56
msgid "The Age header's value is very large."
msgstr "Age 头部的取值非常大。"

#: httplint/field/parsers/age.py:57
msgid ""
"The `Age` header's value is greater than 2,147,483,648. Some "
"implementations may represent it\n"
"using that value (which is over 68 years).\n"
msgstr "`Age` 标头的值大于 2,147,483,648。某些实现可能会使用该值表示（这超过 68 年）。"

#: httplint/field/parsers/cache_control.py:200
#, python-format
msgid "The %(bad_directive)s cache directive's syntax is incorrect."
msgstr "%(bad_directive)s 缓存指令的语法不正确。"

#: httplint/field/parsers/cache_control.py:201
msgid "This value must be an integer."
msgstr "此值必须是整数。"

#: httplint/field/parsers/cache_control.py:207
#, python-format
msgid "The %(directive)s cache directive is very large."
msgstr "%(directive)s 缓存指令非常大。"

#: httplint/field/parsers/cache_control.py:208
#, python-format
msgid ""
"The `%(directive)s` cache directive's value is greater than 2^31-1. Some "
"implementations may not be\n"
"able to handle values this large."
msgstr "`%(directive)s` 缓存指令的值大于 2^31-1。某些实现可能无法处理如此大的值。"

#: httplint/field/parsers/cache_control.py:216
#, python-format
msgid "The %(directive)s cache directive has non-lowercase characters."
msgstr "缓存指令 “%(directive)s” 包含非小写字符。"

#: httplint/field/parsers/cache_control.py:217
#, python-format
msgid ""
"cache directive names are case-insensitive, but some implementations "
"don't\n"
"recognize directives that aren't all-lowercase.\n"
"\n"
"Therefore, it's safest to use `%(directive_lower)s` instead of "
"`%(directive)s`."
msgstr ""
"缓存指令名称不区分大小写，但某些实现不识别非全小写的指令。\n"
"\n"
"因此，使用 `%(directive_lower)s` 而不是 `%(directive)s` 更安全。"

#: httplint/field/parsers/cache_control.py:227
#, python-format
msgid "The %(directive)s cache directive appears more than once."
msgstr "缓存指令 “%(directive)s” 出现多次。"

#: httplint/field/parsers/cache_control.py:228
#, python-format
msgid ""
"The `%(directive)s` cache directive is only defined to appear once; it is"
" used more than\n"
"once here, so implementations may use different instances (e.g., the "
"first, or the last),\n"
"making their behaviour unpredictable."
msgstr ""
"`%(directive)s` "
"缓存指令只允许出现一次；它在这里出现了多次，因此实现可能会使用不同的实例（例如，第一个或最后一个），从而使其行为不可预测。"

#: httplint/field/parsers/cache_control.py:237
#, python-format
msgid "The %(directive)s cache directive overrides other directives."
msgstr "%(directive)s 缓存指令会覆盖其他指令。"

#: httplint/field/parsers/cache_control.py:238
#, python-format
msgid ""
"The `%(directive)s` cache directive overrides or conflicts with these "
"other directives: \n"
"\n"
"%(conflicts)s\n"
"\n"
"The conflicting directives will be ignored by caches, and can be safely "
"omitted.\n"
"    "
msgstr ""
"缓存指令 `%(directive)s` 会覆盖或与以下其他指令冲突：\n"
"\n"
"%(conflicts)s\n"
"\n"
"冲突的指令将被缓存忽略，并且可以安全地省略。"

#: httplint/field/parsers/cache_control.py:250
#, python-format
msgid "The %(directive)s cache directive has no meaning in a %(message_type)s."
msgstr "%(directive)s 缓存指令在 %(message_type)s 中没有意义。"

#: httplint/field/parsers/cache_control.py:251
#, python-format
msgid ""
"The `%(directive)s` cache directive is only defined to appear in "
"%(other_message)s\n"
"messages; is has no defined meaning in a %(message_type)s."
msgstr ""
"缓存指令 `%(directive)s` 只被定义用于 %(other_message)s 消息中；它在 %(message_type)s "
"消息中没有定义含义。"

#: httplint/field/parsers/cache_control.py:259
msgid "Only one of the pre-check and post-check cache directives is present."
msgstr "仅存在预检查和后检查缓存指令中的一个。"

#: httplint/field/parsers/cache_control.py:262
msgid ""
"Microsoft Internet Explorer implements two `Cache-Control` extensions, "
"`pre-check` and\n"
"`post-check`, to give more control over how its cache stores responses.\n"
"\n"
"This response uses only one of these directives; as a result, Internet "
"Explorer will ignore the\n"
"directive, since it requires both to be present.\n"
msgstr ""
"Microsoft Internet Explorer 实现了两个 `Cache-Control` 扩展，“`pre-check`”和"
"“`post-check`”，以更精细地控制其缓存存储响应的方式。\n"
"\n"
"此响应仅使用了这些指令中的一个；因此，Internet Explorer 将忽略该指令，因为它要求同时存在这两个指令。"

#: httplint/field/parsers/cache_control.py:274
msgid "The pre-check and post-check cache directives are both '0'."
msgstr "预检查和后检查缓存指令均为 '0'。"

#: httplint/field/parsers/cache_control.py:277
msgid ""
"Microsoft Internet Explorer implements two `Cache-Control` extensions, "
"`pre-check` and\n"
"`post-check`, to give more control over how its cache stores responses.\n"
"\n"
"This response gives a value of \"0\" for both; as a result, Internet "
"Explorer will ignore the\n"
"directive, since it requires both to be present.\n"
"\n"
"In other words, setting these to zero has **no effect** (besides wasting "
"bandwidth),\n"
"and may trigger bugs in some beta versions of IE."
msgstr ""
"Microsoft Internet Explorer 实现了两个 `Cache-Control` 扩展：`pre-check` 和 `post-"
"check`，以更精细地控制其缓存如何存储响应。\n"
"\n"
"此响应为两者都提供了“0”的值；因此，Internet Explorer 将忽略该指令，因为它要求两者都存在。\n"
"\n"
"换句话说，将这些设置为零**没有效果**（除了浪费带宽），并且可能会在某些 IE beta 版本中触发 bug。"

#: httplint/field/parsers/cache_control.py:291
msgid "The post-check cache directive's value is larger than pre-check's."
msgstr "post-check 缓存指令的值大于 pre-check 的。"

#: httplint/field/parsers/cache_control.py:294
msgid ""
"Microsoft Internet Explorer implements two `Cache-Control` extensions, "
"`pre-check` and\n"
"`post-check`, to give more control over how its cache stores responses.\n"
"\n"
"This response assigns a higher value to `post-check` than to `pre-check`;"
" this means that Internet\n"
"Explorer will treat `post-check` as if its value is the same as `pre-"
"check`'s."
msgstr ""
"Microsoft Internet Explorer 实现两个 `Cache-Control` 扩展，`pre-check` 和 `post-"
"check`，以更好地控制其缓存如何存储响应。\n"
"\n"
"此响应为 `post-check` 分配的值高于 `pre-check`；这意味着 Internet Explorer 将 `post-"
"check` 的处理方式视为与其值相同。"

#: httplint/field/parsers/cache_control.py:305
msgid "The post-check cache directive's value is '0'."
msgstr "post-check 缓存指令的值为 '0'。"

#: httplint/field/parsers/cache_control.py:308
msgid ""
"Microsoft Internet Explorer implements two `Cache-Control` extensions, "
"`pre-check` and\n"
"`post-check`, to give more control over how its cache stores responses.\n"
"\n"
"This response assigns a value of \"0\" to `post-check`, which means that "
"Internet Explorer will reload\n"
"the content as soon as it enters the browser cache, effectively "
"**doubling the load on the\n"
"server**."
msgstr ""
"Microsoft Internet Explorer 实现了两个 `Cache-Control` 扩展，`pre-check` 和 `post-"
"check`，以提供对浏览器缓存存储响应的更多控制。\n"
"\n"
"此响应为 `post-check` 分配了值 \"0\"，这意味着 Internet Explorer "
"一旦将内容加载到浏览器缓存中，就会立即重新加载内容，从而**加倍服务器的负载**。"

#: httplint/field/parsers/cache_control.py:320
msgid "This response may be refreshed in the background by Internet Explorer."
msgstr "此响应可能会由 Internet Explorer 在后台刷新。"

#: httplint/field/parsers/cache_control.py:323
#, python-format
msgid ""
"Microsoft Internet Explorer implements two `Cache-Control` extensions, "
"`pre-check` and\n"
"`post-check`, to give more control over how its cache stores responses.\n"
"\n"
"Once it has been cached for more than %(post_check)s seconds, a new "
"request will result in the\n"
"cached response being served while it is refreshed in the background. "
"However, if it has been\n"
"cached for more than %(pre_check)s seconds, the browser will download a "
"fresh response before\n"
"showing it to the user.\n"
"\n"
"Note that these directives do not have any effect on other clients or "
"caches."
msgstr ""
"Microsoft Internet Explorer 实现了两个 `Cache-Control` 扩展，`pre-check` 和 `post-"
"check`，以提供更精细地控制其缓存如何存储响应。\n"
"\n"
"一旦缓存超过 %(post_check)s 秒，新的请求将提供缓存的响应，同时在后台刷新。但是，如果缓存超过 %(pre_check)s "
"秒，浏览器将在向用户显示之前下载一个全新的响应。\n"
"\n"
"请注意，这些指令对其他客户端或缓存没有任何影响。"

#: httplint/field/parsers/cache_status.py:102
msgid "Detailed information about caching is available."
msgstr "有关缓存的详细信息可供使用。"

#: httplint/field/parsers/cache_status.py:103
#, python-format
msgid ""
"The `Cache-Status` header field indicates how caches have handled the "
"response.\n"
"\n"
"%(status)s\n"
msgstr ""
"`Cache-Status` 标头字段指示缓存如何处理了响应。\n"
"\n"
"%(status)s"

#: httplint/field/parsers/cache_status.py:113
msgid "The Cache-Status header has an invalid structure."
msgstr "Cache-Status 标头结构无效。"

#: httplint/field/parsers/cache_status.py:114
msgid ""
"The `Cache-Status` header must be a list of members, where each member is"
" a \n"
"Token or String (identifying the cache) with optional parameters.\n"
msgstr "`Cache-Status` 标头必须是成员列表，其中每个成员是字符串（标识缓存）或令牌，并带有可选参数。"

#: httplint/field/parsers/cache_status.py:123
#, python-format
msgid "The Cache-Status header has an unknown parameter '%(param)s'."
msgstr "Cache-Status 标头具有未知参数“%(param)s”。"

#: httplint/field/parsers/cache_status.py:124
#, python-format
msgid ""
"The `%(param)s` parameter is not defined in the Cache-Status "
"specification.\n"
msgstr "`%(param)s` 参数未在 Cache-Status 规范中定义。"

#: httplint/field/parsers/cache_status.py:132
#, python-format
msgid "The Cache-Status header has an unknown value for '%(param)s'."
msgstr "Cache-Status 标头中 '%(param)s' 的值未知。"

#: httplint/field/parsers/cache_status.py:133
#: httplint/field/parsers/proxy_status.py:170
#, python-format
msgid "The value `%(value)s` is not defined for the `%(param)s` parameter.\n"
msgstr "参数 `%(param)s` 的值 `%(value)s` 未定义。"

#: httplint/field/parsers/clear_site_data.py:35
#, python-format
msgid "The Clear-Site-Data header contains an unknown value '%(value)s'."
msgstr "Clear-Site-Data 标头包含一个未知值 '%(value)s'。"

#: httplint/field/parsers/clear_site_data.py:36
msgid ""
"The `Clear-Site-Data` header contains a value that is not recognized.\n"
"Valid values are: `\"cache\"`, `\"cookies\"`, `\"storage\"`, "
"`\"executionContexts\"`, `\"*\"`."
msgstr ""
"`Clear-Site-Data` 标头包含一个未识别的值。\n"
"有效值为：`\"cache\"`、`\"cookies\"`、`\"storage\"`、`\"executionContexts\"`、`\"*\"`。"

#: httplint/field/parsers/content_disposition.py:51
#, python-format
msgid "The '%(disposition)s' Content-Disposition isn't known."
msgstr "未知的“%(disposition)s”Content-Disposition。"

#: httplint/field/parsers/content_disposition.py:52
#, python-format
msgid ""
"The `Content-Disposition` header has two widely-known values; `inline` "
"and `attachment`.\n"
"`%(disposition)s` isn't recognised, and most implementations will default"
" to handling it like\n"
"`attachment`."
msgstr ""
"`Content-Disposition` 标头有两个广为人知的取值；`inline` 和 `attachment`。\n"
"`%(disposition)s` 未被识别，大多数实现会将其默认作为 `attachment` 来处理。"

#: httplint/field/parsers/content_disposition.py:61
msgid "The Content-Disposition header doesn't have a 'filename' parameter."
msgstr "Content-Disposition 标头缺少 'filename' 参数。"

#: httplint/field/parsers/content_disposition.py:62
msgid ""
"The `Content-Disposition` header with a disposition of `attachment` "
"suggests a filename for clients\n"
"to use when saving the file locally.\n"
"\n"
"It should always contain a `filename` parameter, even when the "
"`filename*` parameter is used to\n"
"carry an internationalised filename, so that browsers can fall back to an"
" ASCII-only filename."
msgstr ""
"`Content-Disposition` 标头中的 `attachment` 属性表明了一个文件名，供客户端在本地保存文件时使用。\n"
"\n"
"即使使用了 `filename*` 参数来承载国际化文件名，它也应始终包含 `filename` 参数，以便浏览器能够回退到仅包含 ASCII "
"字符的文件名。"

#: httplint/field/parsers/content_disposition.py:73
#, python-format
msgid ""
"The 'filename' parameter on the Content-Disposition header contains a "
"'%%' character."
msgstr "Content-Disposition 头部中的 'filename' 参数包含一个 '%%' 字符。"

#: httplint/field/parsers/content_disposition.py:77
#, python-format
msgid ""
"The `Content-Disposition` header suggests a filename for clients to use "
"when saving the file\n"
"locally, using the `filename` parameter.\n"
"\n"
"[RFC6266](https://www.rfc-editor.org/rfc/rfc6266) specifies how to carry "
"non-ASCII characters in this\n"
"parameter. However, historically some (but not all) browsers have also "
"decoded %%-encoded\n"
"characters in the `filename` parameter, which means that they'll be "
"treated differently depending\n"
"on the browser you're using.\n"
"\n"
"As a result, it's not interoperable to use percent characters in the "
"`filename` parameter. Use the\n"
"correct encoding in the `filename*` parameter instead."
msgstr ""
"`Content-Disposition` 标头使用 `filename` 参数建议客户端在本地保存文件时使用的文件名。\n"
"\n"
"[RFC6266](https://www.rfc-editor.org/rfc/rfc6266) 规定了在此参数中如何传输非 ASCII "
"字符。然而，历史上一些（但不是全部）浏览器也会解码 `filename` 参数中的 %% 编码字符，这意味着它们将根据您使用的浏览器而有所不同。"
"\n"
"\n"
"因此，在 `filename` 参数中使用百分号字符是不互通的。请改用 `filename*` 参数中的正确编码。"

#: httplint/field/parsers/content_disposition.py:93
msgid "The filename in the Content-Disposition header contains a path character."
msgstr "Content-Disposition 标头中的文件名包含路径字符。"

#: httplint/field/parsers/content_disposition.py:96
msgid ""
"The `Content-Disposition` header suggests a filename for clients to use "
"when saving the file\n"
"locally, using the `filename` and `filename*` parameters.\n"
"\n"
"One of these parameters contains a path character (\"\\\" or \"/\"), used"
" to navigate between\n"
"directories on common operating systems.\n"
"\n"
"Because this can be used to attach the browser's host operating system "
"(e.g., by saving a file to a\n"
"system directory), browsers will usually ignore these parameters, or "
"remove path information.\n"
"\n"
"You should remove these characters."
msgstr ""
"`Content-Disposition` 标头使用 `filename` 和 `filename*` "
"参数，建议客户端在本地保存文件时使用的文件名。\n"
"\n"
"其中一个参数包含一个路径字符（“\\” 或 “/”），用于在常见操作系统中导航目录。\n"
"\n"
"因为这可用于附加浏览器的宿主操作系统（例如，将文件保存到系统目录），浏览器通常会忽略这些参数，或删除路径信息。\n"
"\n"
"您应该删除这些字符。"

#: httplint/field/parsers/content_encoding.py:35
msgid "This response contained unwanted content-codings."
msgstr "此响应包含不期望的内容编码。"

#: httplint/field/parsers/content_encoding.py:36
#, python-format
msgid ""
"This response's `Content-Encoding` header indicates it has content-"
"codings applied\n"
"(`%(unwanted_codings)s`) that the request didn't ask for.\n"
"\n"
"Normally, clients ask for the encodings they want in the `Accept-"
"Encoding` request header. Using\n"
"encodings that the client doesn't explicitly request can lead to "
"interoperability problems."
msgstr ""
"此响应的 `Content-Encoding` 标头表明应用了请求未要求的编码（`%(unwanted_codings)s`）。\n"
"\n"
"通常，客户端会在 `Accept-Encoding` 请求标头中请求它们想要的编码。使用客户端未明确请求的编码可能导致互操作性问题。"

#: httplint/field/parsers/content_language.py:37
#, python-format
msgid "The %(lang)s language tag appears more than once."
msgstr "语言标签 %(lang)s 出现次数超过一次。"

#: httplint/field/parsers/content_language.py:38
#, python-format
msgid ""
"The `%(lang)s` language tag is used more than once in the `Content-"
"Language` header.\n"
"\n"
"Recipients will likely ignore duplicates."
msgstr ""
"`Content-Language` 标头中多次使用了 `%(lang)s` 语言标记。\n"
"\n"
"接收方很可能会忽略重复项。"

#: httplint/field/parsers/content_length.py:44
msgid "Content-Length and Transfer-Encoding should not be present together."
msgstr "Content-Length 和 Transfer-Encoding 不应同时存在。"

#: httplint/field/parsers/content_length.py:45
msgid ""
"RFC 9110 Section 8.6:\n"
"> A sender MUST NOT send a Content-Length header field in any message "
"that contains a Transfer-Encoding header field.\n"
"\n"
"This is because `Transfer-Encoding` overrides `Content-Length`."
msgstr ""
"RFC 9110 Section 8.6：\n"
"> 发送方不得在包含 Transfer-Encoding 报头字段的任何消息中发送 Content-Length 报头字段。\n"
"\n"
"这是因为 `Transfer-Encoding` 会覆盖 `Content-Length`。"

#: httplint/field/parsers/content_length.py:55
msgid "The Content-Length header is very large."
msgstr "Content-Length 标头非常大。"

#: httplint/field/parsers/content_length.py:56
msgid ""
"The `Content-Length` header's value is greater than 2^63-1. Some "
"implementations may not be able to\n"
"handle values this large."
msgstr "`Content-Length` 标头的值大于 2^63-1。某些实现可能无法处理如此大的值。"

#: httplint/field/parsers/content_range.py:37
msgid "This response shouldn't have a Content-Range header."
msgstr "此响应不应带有 Content-Range 标头。"

#: httplint/field/parsers/content_range.py:38
msgid ""
"HTTP only defines meaning for the `Content-Range` header in responses "
"with a `206` (Partial\n"
"Content) or `416` (Requested Range Not Satisfiable) status code.\n"
"\n"
"Because the status code is neither of those, this `Content-Range` header "
"may confuse caches and\n"
"clients."
msgstr ""
"HTTP 仅在响应状态码为 `206` (部分内容) 或 `416` (请求范围不满足) 时定义 `Content-Range` 报头。\n"
"\n"
"由于状态码不是这两者之一，此 `Content-Range` 报头可能会混淆缓存和客户端。"

#: httplint/field/parsers/content_security_policy.py:126
#, python-format
msgid "This response sets a Content Security Policy%(report_only)s."
msgstr "此响应设置了内容安全策略%(report_only)s。"

#: httplint/field/parsers/content_security_policy.py:127
#, python-format
msgid ""
"[Content Security Policy](https://www.w3.org/TR/CSP3/) allows the server "
"to declare\n"
"the sources of content that browsers are allowed to use on a "
"page.%(report_only_text)s"
msgstr ""
"[内容安全策略](https://www.w3.org/TR/CSP3/) "
"允许服务器声明浏览器允许在页面上使用的内容的来源。%(report_only_text)s"

#: httplint/field/parsers/content_security_policy.py:135
msgid "Inline scripts are allowed."
msgstr "内联脚本是允许的。"

#: httplint/field/parsers/content_security_policy.py:136
#, python-format
msgid ""
"The `'unsafe-inline'` [Content Security "
"Policy](https://www.w3.org/TR/CSP3/)\n"
"directive allows the execution of inline scripts and event handlers, "
"which\n"
"significantly reduces the protection provided by CSP against Cross-Site\n"
"Scripting (XSS) attacks.\n"
"\n"
"It was found in the following directives:\n"
"\n"
"%(directives_list)s"
msgstr ""
"`'unsafe-inline'` [内容安全策略](https://www.w3.org/TR/CSP3/)\n"
"指令允许执行内联脚本和事件处理程序，这会大大削弱 CSP 对跨站脚本 (XSS) 攻击的防护能力。\n"
"\n"
"在以下指令中发现：\n"
"\n"
"%(directives_list)s"

#: httplint/field/parsers/content_security_policy.py:150
msgid "Unsafe script evaluation is allowed."
msgstr "允许不安全的脚本评估。"

#: httplint/field/parsers/content_security_policy.py:151
#, python-format
msgid ""
"The `'unsafe-eval'` [Content Security "
"Policy](https://www.w3.org/TR/CSP3/)\n"
"directive allows the use of string-to-code mechanisms like `eval()`, "
"which can make it easier for\n"
"attackers to execute malicious code.\n"
"\n"
"It was found in the following directives:\n"
"\n"
"%(directives_list)s"
msgstr ""
"`'unsafe-eval'` [Content Security Policy](https://www.w3.org/TR/CSP3/)\n"
"指令允许使用字符串到代码的机制（例如 `eval()`），这可能使攻击者更容易执行恶意代码。\n"
"\n"
"在以下指令中发现：\n"
"\n"
"%(directives_list)s"

#: httplint/field/parsers/content_security_policy.py:164
msgid "Loading from insecure HTTP sources is allowed."
msgstr "允许从不安全的 HTTP 源加载。"

#: httplint/field/parsers/content_security_policy.py:165
#, python-format
msgid ""
"Allowing `http:` sources in `%(field_name)s` can allow attackers to "
"intercept and modify\n"
"content loaded by the page, potentially bypassing security controls.\n"
"\n"
"It was found in the following directives:\n"
"\n"
"%(directives_list)s"
msgstr ""
"在 `%(field_name)s` 中允许 `http:` 源，可能使攻击者能够拦截和修改页面加载的内容，从而绕过安全控制。\n"
"\n"
"在以下指令中发现了此问题：\n"
"\n"
"%(directives_list)s"

#: httplint/field/parsers/content_security_policy.py:177
msgid "Duplicate directives are present."
msgstr "重复的指令存在。"

#: httplint/field/parsers/content_security_policy.py:178
#, python-format
msgid ""
"Directives must only appear once in the `%(field_name)s` header; "
"subsequent occurrences are ignored.\n"
"\n"
"The following directives were duplicated:\n"
"\n"
"%(directives_list)s"
msgstr ""
"指令在 `%(field_name)s` 标头中只能出现一次；后续的出现将被忽略。\n"
"\n"
"以下指令已重复：\n"
"\n"
"%(directives_list)s"

#: httplint/field/parsers/content_security_policy.py:189
msgid "The deprecated report-uri directive is used."
msgstr "已使用已弃用的 report-uri 指令。"

#: httplint/field/parsers/content_security_policy.py:190
msgid ""
"The `report-uri` [Content Security Policy](https://www.w3.org/TR/CSP3/)\n"
"directive is deprecated in favor of `report-to`. It is recommended to use"
" `report-to`\n"
"for reporting violations, although `report-uri` may still be supported "
"for backward\n"
"compatibility."
msgstr ""
"`report-uri` [Content Security Policy](https://www.w3.org/TR/CSP3/)\n"
"指令已弃用，推荐使用 `report-to`。建议使用 `report-to`\n"
"来报告违规，但 `report-uri` 可能仍出于向后兼容性而受支持。"

#: httplint/field/parsers/content_security_policy.py:200
msgid "All sources are allowed in one or more directives."
msgstr "所有来源都允许在一条或多条指令中。"

#: httplint/field/parsers/content_security_policy.py:201
#, python-format
msgid ""
"The `*` [Content Security Policy](https://www.w3.org/TR/CSP3/)\n"
"directive allows resources to be loaded from any origin, which "
"significantly reduces the protection\n"
"provided by CSP.%(report_only_text)s\n"
"\n"
"It was found in the following directives:\n"
"\n"
"%(directives_list)s"
msgstr ""
"`*` [内容安全策略](https://www.w3.org/TR/CSP3/) 指令允许从任何来源加载资源，这大大降低了 CSP "
"提供的保护。%(report_only_text)s\n"
"\n"
"在以下指令中发现：\n"
"\n"
"%(directives_list)s"

#: httplint/field/parsers/cross_origin_embedder_policy.py:71
#, python-format
msgid "This response requires resources to have a CORP header%(report_only)s."
msgstr "此响应要求资源具有 CORP 标头%(report_only)s。"

#: httplint/field/parsers/cross_origin_embedder_policy.py:72
#, python-format
msgid ""
"The `require-corp`\n"
"[Cross Origin Embedder Policy](https://fetch.spec.whatwg.org/#cross-"
"origin-embedder-policy-header)\n"
"requires that all cross-origin resources must explicitly grant permission"
" to be loaded via a\n"
"`Cross-Origin-Resource-Policy` header, in supporting "
"browsers.%(report_only_text)s"
msgstr ""
"`require-corp`\n"
"[Cross Origin Embedder Policy](https://fetch.spec.whatwg.org/#cross-"
"origin-embedder-policy-header)\n"
"要求在支持的浏览器中，所有跨域资源都必须通过 `Cross-Origin-Resource-Policy` "
"头部明确授予加载权限。%(report_only_text)s"

#: httplint/field/parsers/cross_origin_embedder_policy.py:82
#, python-format
msgid ""
"This response loads cross-origin resources without "
"credentials%(report_only)s."
msgstr "此响应在未携带凭证的情况下加载跨域资源%(report_only)s。"

#: httplint/field/parsers/cross_origin_embedder_policy.py:85
#, python-format
msgid ""
"The `credentialless`\n"
"[Cross-Origin Embedder Policy](https://fetch.spec.whatwg.org/#cross-"
"origin-embedder-policy-header)\n"
"allows loading cross-origin resources without explicit permission in "
"supporting browsers, but\n"
"requests for them will not include credentials (cookies, client "
"certificates,\n"
"etc.).%(report_only_text)s"
msgstr ""
"`credentialless`\n"
"[Cross-Origin Embedder Policy](https://fetch.spec.whatwg.org/#cross-"
"origin-embedder-policy-header)\n"
"允许在支持的浏览器中加载跨源资源，而无需显式权限，但对它们的请求不包含凭据（Cookie、客户端证书等）。%(report_only_text)s"

#: httplint/field/parsers/cross_origin_embedder_policy.py:96
#, python-format
msgid ""
"This response allows loading cross-origin resources without "
"restriction%(report_only)s."
msgstr "此响应允许无限制地加载跨域资源%(report_only)s。"

#: httplint/field/parsers/cross_origin_embedder_policy.py:100
#, python-format
msgid ""
"The `unsafe-none`\n"
"[Cross-Origin Embedder Policy](https://fetch.spec.whatwg.org/#cross-"
"origin-embedder-policy-header)\n"
"is the default behavior, allowing cross-origin resources to be loaded\n"
"without explicit permission in supporting browsers.\n"
"\n"
"This does not provide cross-origin isolation.%(report_only_text)s"
msgstr ""
"`unsafe-none`\n"
"[Cross-Origin Embedder Policy](https://fetch.spec.whatwg.org/#cross-"
"origin-embedder-policy-header)\n"
"是默认行为，允许在支持的浏览器中加载跨源资源\n"
"而无需显式权限。\n"
"\n"
"这不提供跨源隔离。%(report_only_text)s"

#: httplint/field/parsers/cross_origin_embedder_policy.py:112
#: httplint/field/parsers/cross_origin_opener_policy.py:111
#, python-format
msgid "This response's %(field_name)s has an invalid value."
msgstr "此响应的 %(field_name)s 具有无效值。"

#: httplint/field/parsers/cross_origin_embedder_policy.py:113
#, python-format
msgid ""
"The `%(field_name)s` header must be one of `require-corp`, "
"`credentialless`, or\n"
"`unsafe-none`.\n"
msgstr "`%(field_name)s` 标头必须是 `require-corp`、`credentialless` 或 `unsafe-none` 之一。"

#: httplint/field/parsers/cross_origin_embedder_policy_report_only.py:34
msgid "This response has both enforcing and report-only COEP headers."
msgstr "此响应同时具有强制和仅报告的 COEP 标头。"

#: httplint/field/parsers/cross_origin_embedder_policy_report_only.py:35
msgid ""
"A response should not have both `Cross-Origin-Embedder-Policy` and\n"
"`Cross-Origin-Embedder-Policy-Report-Only` headers. The report-only "
"header will be ignored."
msgstr ""
"响应不应同时包含 `Cross-Origin-Embedder-Policy` 和 `Cross-Origin-Embedder-Policy-"
"Report-Only` 标头。report-only 标头将被忽略。"

#: httplint/field/parsers/cross_origin_opener_policy.py:71
#, python-format
msgid ""
"This response isolates the browsing context to the same "
"origin%(report_only)s."
msgstr "此响应将浏览上下文限制在同源%(report_only)s。"

#: httplint/field/parsers/cross_origin_opener_policy.py:74
#, python-format
msgid ""
"The `same-origin`\n"
"[Cross-Origin Opener "
"Policy](https://html.spec.whatwg.org/multipage/origin.html#coop)\n"
"isolates the browsing context, preventing it from sharing a window object"
"\n"
"with cross-origin documents in supporting browsers.%(report_only_text)s"
msgstr ""
"`same-origin`\n"
"[跨源打开策略](https://html.spec.whatwg.org/multipage/origin.html#coop)\n"
"会隔离浏览上下文，阻止其在支持的浏览器中与跨源文档共享窗口对象。%(report_only_text)s"

#: httplint/field/parsers/cross_origin_opener_policy.py:84
#, python-format
msgid ""
"This response isolates the browsing context but allows "
"popups%(report_only)s."
msgstr "此响应隔离了浏览上下文，但允许弹出窗口%(report_only)s。"

#: httplint/field/parsers/cross_origin_opener_policy.py:87
#, python-format
msgid ""
"The `same-origin-allow-popups`\n"
"[Cross-Origin Opener "
"Policy](https://html.spec.whatwg.org/multipage/origin.html#coop)\n"
"isolates the browsing context but maintains a relationship\n"
"with popups that it opens, or that opened it, in supporting "
"browsers.%(report_only_text)s"
msgstr ""
"`same-origin-allow-popups`\n"
"[跨源打开者策略](https://html.spec.whatwg.org/multipage/origin.html#coop)\n"
"会隔离浏览上下文，但会在支持的浏览器中与它打开的弹出窗口，或打开它的弹出窗口保持关联。%(report_only_text)s"

#: httplint/field/parsers/cross_origin_opener_policy.py:97
#, python-format
msgid ""
"This response allows sharing the browsing context with cross-origin "
"documents%(report_only)s."
msgstr "此响应允许与跨域文档共享浏览上下文%(report_only)s。"

#: httplint/field/parsers/cross_origin_opener_policy.py:101
#, python-format
msgid ""
"The `unsafe-none`\n"
"[Cross-Origin Opener "
"Policy](https://html.spec.whatwg.org/multipage/origin.html#coop)\n"
"is the default behavior in supporting browsers. It allows the document to"
" share a browsing context\n"
"group with other documents unless they enforce "
"isolation.%(report_only_text)s"
msgstr ""
"`unsafe-none`\n"
"[跨源打开策略](https://html.spec.whatwg.org/multipage/origin.html#coop)\n"
"是支持浏览器的默认行为。它允许文档与其他强制隔离的文档共享浏览上下文组。%(report_only_text)s"

#: httplint/field/parsers/cross_origin_opener_policy.py:112
#, python-format
msgid ""
"The `%(field_name)s` header must be one of `same-origin`, `same-origin-"
"allow-popups`,\n"
"or `unsafe-none`.\n"
msgstr ""
"`%(field_name)s` 标头必须是 `same-origin`、`same-origin-allow-popups` 或 "
"`unsafe-none` 之一。"

#: httplint/field/parsers/cross_origin_opener_policy_report_only.py:34
msgid "This response has both enforcing and report-only COOP headers."
msgstr "此响应同时包含强制和仅报告的 COOP 标头。"

#: httplint/field/parsers/cross_origin_opener_policy_report_only.py:35
msgid ""
"A response should not have both `Cross-Origin-Opener-Policy` and\n"
"`Cross-Origin-Opener-Policy-Report-Only` headers. The report-only header "
"will be ignored."
msgstr ""
"响应不应同时包含 `Cross-Origin-Opener-Policy` 和 `Cross-Origin-Opener-Policy-"
"Report-Only` 标头。report-only 标头将被忽略。"

#: httplint/field/parsers/cross_origin_resource_policy.py:41
msgid ""
"This response is only available for reading to requests from the same "
"origin."
msgstr "此响应仅对来自同一来源的请求可用。"

#: httplint/field/parsers/cross_origin_resource_policy.py:44
#, python-format
msgid ""
"The `same-origin`\n"
"[Cross-Origin Resource Policy](https://fetch.spec.whatwg.org/#cross-"
"origin-resource-policy-header)\n"
"prevents the resource from being read by any cross-origin document \n"
"in supporting browsers.%(report_only_text)s"
msgstr ""
"`same-origin`\n"
"[跨源资源策略](https://fetch.spec.whatwg.org/#cross-origin-resource-policy-"
"header)\n"
"可防止支持的浏览器中的任何跨源文档读取该资源。%(report_only_text)s"

#: httplint/field/parsers/cross_origin_resource_policy.py:54
msgid "This response is available for reading to requests from the same site."
msgstr "此响应可供同一来源的请求读取。"

#: httplint/field/parsers/cross_origin_resource_policy.py:55
#, python-format
msgid ""
"The `same-site`\n"
"[Cross-Origin Resource Policy](https://fetch.spec.whatwg.org/#cross-"
"origin-resource-policy-header)\n"
"allows the resource to be read by documents from the same site, but\n"
"prevents it from being read by cross-site documents in supporting "
"browsers.%(report_only_text)s"
msgstr ""
"`same-site`\n"
"[跨源资源策略](https://fetch.spec.whatwg.org/#cross-origin-resource-policy-"
"header)\n"
"允许来自同一站点的文档读取资源，但在支持的浏览器中会阻止跨站文档读取该资源。%(report_only_text)s"

#: httplint/field/parsers/cross_origin_resource_policy.py:65
msgid "This response is available for reading to requests from all origins."
msgstr "此响应可供所有来源的请求进行读取。"

#: httplint/field/parsers/cross_origin_resource_policy.py:66
#, python-format
msgid ""
"The `cross-origin`\n"
"[Cross-Origin Resource Policy](https://fetch.spec.whatwg.org/#cross-"
"origin-resource-policy-header)\n"
"allows the resource to be read by any document in supporting browsers, "
"regardless of its \n"
"origin.%(report_only_text)s"
msgstr ""
"`cross-origin`\n"
"[同源资源策略](https://fetch.spec.whatwg.org/#cross-origin-resource-policy-"
"header)\n"
"允许支持浏览器的任何文档读取该资源，无论其来源如何。%(report_only_text)s"

#: httplint/field/parsers/cross_origin_resource_policy.py:76
msgid "Cross-Origin-Resource-Policy has an invalid value."
msgstr "Cross-Origin-Resource-Policy 的值无效。"

#: httplint/field/parsers/cross_origin_resource_policy.py:77
#, python-format
msgid ""
"`%(value)s` is not a valid value for the `Cross-Origin-Resource-Policy` "
"header;\n"
"it must be one of `same-origin`, `same-site`, or `cross-origin`.\n"
msgstr ""
"`%(value)s` 不是 `Cross-Origin-Resource-Policy` 标头的一个有效值；\n"
"它必须是 `same-origin`、`same-site` 或 `cross-origin` 之一。"

#: httplint/field/parsers/date.py:51
msgid "The server's clock is correct."
msgstr "服务器的时钟是正确的。"

#: httplint/field/parsers/date.py:52
msgid ""
"HTTP's caching model assumes reasonable synchronisation between clocks on"
" the server and client;\n"
"compared to the local clock, the server's clock appears to be well-"
"synchronised."
msgstr ""
"HTTP 的缓存模型假定服务器和客户端的时钟在合理范围内同步；\n"
"与本地时钟相比，服务器的时钟似乎同步得很好。"

#: httplint/field/parsers/date.py:60
#, python-format
msgid "The server's clock is %(clock_skew_string)s."
msgstr "服务器时钟为 %(clock_skew_string)s。"

#: httplint/field/parsers/date.py:61
msgid ""
"Compared to the local clock, the server's clock does not appear to be "
"well-synchronised.\n"
"\n"
"HTTP's caching model assumes reasonable synchronisation between clocks on"
" the server and client;\n"
"clock skew can cause responses that should be cacheable to be considered "
"uncacheable (especially if\n"
"their freshness lifetime is short).\n"
"\n"
"Ask your server administrator to synchronise the clock, e.g., using\n"
"[NTP](http://en.wikipedia.org/wiki/Network_Time_Protocol Network Time "
"Protocol).\n"
"\n"
"Apparent clock skew can also be caused by caching the response without "
"adjusting the `Age` header;\n"
"e.g., in a reverse proxy or Content Delivery network. See [this\n"
"paper](https://www.usenix.org/legacy/events/usits01/full_papers/cohen/cohen_html/index.html)"
" for more information. "
msgstr ""
"与本地时钟相比，服务器时钟似乎未正确同步。\n"
"\n"
"HTTP 的缓存模型假定服务器和客户端之间的时钟大致同步；\n"
"时钟偏差可能导致本应可缓存的响应被视为不可缓存（尤其是在\n"
"其新鲜度寿命很短的情况下）。\n"
"\n"
"请让您的服务器管理员同步时钟，例如使用\n"
"[NTP](http://en.wikipedia.org/wiki/Network_Time_Protocol 网络时间协议)。\n"
"\n"
"响应未调整 `Age` 标头进行缓存也会导致明显的时钟偏差；\n"
"例如，在反向代理或内容分发网络中。有关更多信息，请参阅[此\n"
"论文](https://www.usenix.org/legacy/events/usits01/full_papers/cohen/cohen_html/index.html)。"

#: httplint/field/parsers/date.py:79
msgid "It appears that the Date header has been changed by an intermediary."
msgstr "看起来 Date 报头已被中间人修改。"

#: httplint/field/parsers/date.py:80
msgid ""
"It appears that this response has been cached by a reverse proxy or "
"Content Delivery Network,\n"
"because the `Age` header is present, but the `Date` header is more recent"
" than it indicates.\n"
"\n"
"Generally, reverse proxies should either omit the `Age` header (if they "
"have another means of\n"
"determining how fresh the response is), or leave the `Date` header alone "
"(i.e., act as a normal\n"
"HTTP cache).\n"
"\n"
"See [this "
"paper](https://www.usenix.org/legacy/events/usits01/full_papers/cohen/cohen_html/index.html)"
"\n"
"for more information."
msgstr ""
"看起来此响应已被反向代理或内容分发网络缓存，\n"
"因为存在 `Age` 标头，但 `Date` 标头比其指示的更近。\n"
"\n"
"通常，反向代理应省略 `Age` 标头（如果它们有其他方法\n"
"确定响应的新鲜度），或者不更改 `Date` 标头（即，表现得像一个普通的\n"
"HTTP 缓存）。\n"
"\n"
"有关更多信息，请参阅[这篇论文](https://www.usenix.org/legacy/events/usits01/full_papers/cohen/cohen_html/index.html)。"

#: httplint/field/parsers/expect.py:37
#, python-format
msgid "The '%(expectation)s' expectation is not supported."
msgstr "'% (expectation)s' 期望不受支持。"

#: httplint/field/parsers/expect.py:38
msgid ""
"HTTP only defines one expectation, `100-continue`. This expectation is "
"not recognized."
msgstr "HTTP 仅定义了一种 Expectation，即 `100-continue`。此 Expectation 未被识别。"

#: httplint/field/parsers/expect.py:45
msgid "The Expect header is not supported in HTTP/1.0."
msgstr "Expect 头在 HTTP/1.0 中不受支持。"

#: httplint/field/parsers/expect.py:46
msgid "The `Expect` header was added in HTTP/1.1; it has no meaning in HTTP/1.0."
msgstr "`Expect` 标头是在 HTTP/1.1 中添加的；它在 HTTP/1.0 中没有意义。"

#: httplint/field/parsers/last_modified.py:44
msgid "The Last-Modified time is in the future."
msgstr "最后修改时间在未来。"

#: httplint/field/parsers/last_modified.py:45
msgid ""
"The `Last-Modified` header indicates the last point in time that the "
"resource has changed.\n"
"This response's `Last-Modified` time is in the future, which doesn't have"
" any defined meaning in\n"
"HTTP."
msgstr ""
"`Last-Modified` 标头指示资源上次修改的时间点。\n"
"此响应的 `Last-Modified` 时间是将来时，在 HTTP 中没有明确的含义。"

#: httplint/field/parsers/last_modified.py:54
#, python-format
msgid "The resource last changed %(last_modified_string)s."
msgstr "该资源上次修改时间是 %(last_modified_string)s。"

#: httplint/field/parsers/last_modified.py:55
#, python-format
msgid ""
"The `Last-Modified` header indicates the last point in time that the "
"resource has changed. It is\n"
"used in HTTP for validating cached responses, and for calculating "
"heuristic freshness in caches.\n"
"\n"
"This resource last changed %(last_modified_string)s."
msgstr ""
"`Last-Modified` 标头指示资源最后一次更改的时间点。它用于 HTTP 中验证缓存的响应，以及计算缓存的启发式新鲜度。\n"
"\n"
"此资源最后一次更改时间为 %(last_modified_string)s。"

#: httplint/field/parsers/link.py:52
msgid "The 'rev' parameter on the Link header is deprecated."
msgstr "Link 响应头上的 'rev' 参数已弃用。"

#: httplint/field/parsers/link.py:53
msgid ""
"The `Link` header, defined by [RFC5988](https://www.rfc-"
"editor.org/rfc/rfc5988#section-5), uses the\n"
"`rel` parameter to communicate the type of a link. `rev` is deprecated by"
" that specification\n"
"because it is often confusing.\n"
"\n"
"Use `rel` and an appropriate relation."
msgstr ""
"`Link` 标头，由 [RFC5988](https://www.rfc-editor.org/rfc/rfc5988#section-5) "
"定义，使用\n"
"`rel` 参数来传达链接的类型。`rev` 已在该规范中弃用，\n"
"因为它经常令人困惑。\n"
"\n"
"请使用 `rel` 和一个合适的关联。"

#: httplint/field/parsers/link.py:64
#, python-format
msgid "The 'anchor' parameter on the %(link)s Link header isn't a URI."
msgstr "‘%(link)s’ 链接头部中的 ‘anchor’ 参数不是一个 URI。"

#: httplint/field/parsers/link.py:65
#, python-format
msgid ""
"The `Link` header, defined by [RFC5988](https://www.rfc-"
"editor.org/rfc/rfc5988#section-5), uses the\n"
"`anchor` parameter to define the context URI for the link.\n"
"\n"
"This parameter can be an absolute or relative URI; however, `%(anchor)s` "
"is neither."
msgstr ""
"`Link` 标头（根据 [RFC5988](https://www.rfc-editor.org/rfc/rfc5988#section-5) "
"定义）使用\n"
"`anchor` 参数来定义链接的上下文 URI。\n"
"\n"
"此参数可以是绝对 URI 或相对 URI；然而，`%(anchor)s` 既不是。"

#: httplint/field/parsers/location.py:51
msgid "This status code doesn't define any meaning for the Location header."
msgstr "此状态码对 Location 标头没有定义任何含义。"

#: httplint/field/parsers/location.py:52
msgid ""
"The `Location` header is used for specific purposes in HTTP; mostly to "
"indicate the URI of another\n"
"resource (e.g., in redirection, or when a new resource is created).\n"
"\n"
"In other status codes (such as this one) it doesn't have a defined "
"meaning, so any use of it won't\n"
"be interoperable.\n"
"\n"
"Sometimes `Location` is confused with `Content-Location`, which indicates"
" a URI for the payload of\n"
"the message that it appears in."
msgstr ""
"`Location` 标头在 HTTP 中有特定用途；主要用于指示另一个资源的 URI（例如，在重定向时，或创建新资源时）。\n"
"\n"
"在其他状态代码（例如此状态代码）中，它没有明确的含义，因此任何使用它都不会具有互操作性。\n"
"\n"
"有时 `Location` 会与 `Content-Location` 混淆，后者指示其所在消息的负载的 URI。"

#: httplint/field/parsers/location.py:66
msgid "The Location header contains a relative URI."
msgstr "Location 标头包含相对 URI。"

#: httplint/field/parsers/location.py:67
#, python-format
msgid ""
"`Location` was originally specified to contain an absolute, not relative,"
" URI.\n"
"\n"
"It is in the process of being updated, and most clients will work around "
"this.\n"
"\n"
"The correct absolute URI is (probably): `%(full_uri)s`"
msgstr ""
"`Location` 最初被指定为包含绝对 URI，而不是相对 URI。\n"
"\n"
"它正在更新过程中，大多数客户端会对此进行规避。\n"
"\n"
"正确的绝对 URI（可能）是：`%(full_uri)s`"

#: httplint/field/parsers/max_forwards.py:11
msgid "The Max-Forwards header is ignored for this method."
msgstr "Max-Forwards 标头不适用于此方法。"

#: httplint/field/parsers/max_forwards.py:12
msgid ""
"The `Max-Forwards` header is only defined for `TRACE` and `OPTIONS` "
"requests; for other methods, it\n"
"is likely to be ignored."
msgstr ""
"`Max-Forwards` 标头仅为 `TRACE` 和 `OPTIONS` 请求定义；对于其他方法，它\n"
"很可能被忽略。"

#: httplint/field/parsers/permissions_policy.py:73
msgid "This response sets a Permissions Policy."
msgstr "此响应设置了 Permissions Policy。"

#: httplint/field/parsers/permissions_policy.py:74
msgid ""
"The `Permissions-Policy` header allows a site to control the use of "
"browser features."
msgstr "`Permissions-Policy` 标头允许网站控制浏览器功能的使用。"

#: httplint/field/parsers/permissions_policy.py:81
#, python-format
msgid "The '%(feature)s' feature is allowed for all origins."
msgstr "“%(feature)s”功能允许所有来源。"

#: httplint/field/parsers/permissions_policy.py:82
#, python-format
msgid ""
"The `%(feature)s` feature is allowed for all origins (using `*`).\n"
"This is insecure and should be restricted to specific origins or `self`."
msgstr ""
"`%(feature)s` 功能对所有来源（使用 `*`）都允许。\n"
"这是不安全的，应该限制为特定来源或 `self`。"

#: httplint/field/parsers/permissions_policy.py:90
#, python-format
msgid "The value for '%(feature)s' should be an Inner List or the token '*'."
msgstr "'%(feature)s' 的值应为 Inner List 或 '*' 令牌。"

#: httplint/field/parsers/permissions_policy.py:91
#, python-format
msgid ""
"The value for the `%(feature)s` feature in `Permissions-Policy` is "
"invalid. It should be either\n"
"an Inner List of origins (e.g., `(self \"https://example.com\")`) or the "
"special token `*`."
msgstr ""
"`Permissions-Policy` 中 `%(feature)s` 功能的值无效。它应该是 origin 的内部列表（例如 `(self "
"\"https://example.com\")`）或特殊标记 `*`。"

#: httplint/field/parsers/permissions_policy.py:99
#, python-format
msgid "'%(token)s' is not valid in an allowlist."
msgstr "'%(token)s' 不在允许列表中。"

#: httplint/field/parsers/permissions_policy.py:100
#, python-format
msgid ""
"The token `%(token)s` is not a valid keyword in an allowlist.\n"
"Valid tokens are `self` and `src`."
msgstr ""
"令牌 `%(token)s` 不是 allowlist 中的有效关键字。\n"
"有效令牌为 `self` 和 `src`。"

#: httplint/field/parsers/permissions_policy.py:108
#, python-format
msgid "The value '%(value)s' looks like a keyword but is a string."
msgstr "值 '%(value)s' 看起来像一个关键字，但它是一个字符串。"

#: httplint/field/parsers/permissions_policy.py:109
#, python-format
msgid ""
"The value `%(value)s` is a string, but it looks like a keyword.\n"
"If you meant to use the keyword, remove the quotes (e.g., `self` instead "
"of `\"self\"`)."
msgstr ""
"值 `%(value)s` 是一个字符串，但它看起来像一个关键字。\n"
"如果你的意思是使用关键字，请移除引号（例如，使用 `self` 而不是 `\"self\"`）。"

#: httplint/field/parsers/permissions_policy.py:117
#, python-format
msgid "The item '%(item)s' is not a valid type for an allowlist."
msgstr "项目 '%(item)s' 不是允许列表的有效类型。"

#: httplint/field/parsers/permissions_policy.py:118
#, python-format
msgid ""
"The item `%(item)s` is not a valid type for an allowlist.\n"
"Allowlists should contain origins (strings) or keywords (tokens)."
msgstr ""
"条目 `%(item)s` 不是允许列表的有效类型。\n"
"允许列表应包含源（字符串）或关键字（令牌）。"

#: httplint/field/parsers/pragma.py:37
msgid "Pragma: no-cache is a request directive, not a response directive."
msgstr "Pragma: no-cache 是一个请求指令，而非响应指令。"

#: httplint/field/parsers/pragma.py:38
msgid ""
"`Pragma` is a very old request header that is sometimes used as a "
"response header, even though\n"
"this is not specified behaviour. `Cache-Control: no-cache` is more "
"appropriate."
msgstr ""
"`Pragma` 是一个非常旧的请求头，有时也会被用作响应头，尽管\n"
"这并不是指定的行为。`Cache-Control: no-cache` 是更合适的选择。"

#: httplint/field/parsers/pragma.py:46
msgid "The Pragma header is being used in an undefined way."
msgstr "Pragma 头标的用法未定义。"

#: httplint/field/parsers/pragma.py:47
msgid ""
"HTTP only defines `Pragma: no-cache`; other uses of this header are "
"deprecated."
msgstr "HTTP 仅定义 `Pragma: no-cache`；此标头的其他用法已弃用。"

#: httplint/field/parsers/proxy_status.py:139
msgid "Information about intermediaries is available."
msgstr "关于中介机构的信息是可用的。"

#: httplint/field/parsers/proxy_status.py:140
#, python-format
msgid ""
"The `Proxy-Status` header field indicates how intermediaries have handled"
" the response.\n"
"\n"
"%(status)s\n"
msgstr ""
"`Proxy-Status` 标头字段指示了中间服务器如何处理了响应。\n"
"\n"
"%(status)s"

#: httplint/field/parsers/proxy_status.py:150
msgid "The Proxy-Status header has an invalid structure."
msgstr "Proxy-Status 标头具有无效的结构。"

#: httplint/field/parsers/proxy_status.py:151
msgid ""
"The `Proxy-Status` header must be a list of members, where each member is"
"\n"
"a Token or String (identifying the proxy) with optional parameters.\n"
msgstr "`Proxy-Status` 头部必须是一个成员列表，其中每个成员是一个 Token 或 String（用于标识代理），并带有可选的参数。"

#: httplint/field/parsers/proxy_status.py:160
#, python-format
msgid "The Proxy-Status header has an unknown parameter '%(param)s'."
msgstr "Proxy-Status 标头有一个未知的参数 '%(param)s'。"

#: httplint/field/parsers/proxy_status.py:161
#, python-format
msgid ""
"The `%(param)s` parameter is not defined in the Proxy-Status "
"specification.\n"
msgstr "`%(param)s` 参数在 Proxy-Status 规范中未定义。"

#: httplint/field/parsers/proxy_status.py:169
#, python-format
msgid "The Proxy-Status header has an unknown value for '%(param)s'."
msgstr "Proxy-Status 标头对 '%(param)s' 具有未知值。"

#: httplint/field/parsers/referer.py:17
msgid "The Referer header is sent from a secure origin to an insecure target."
msgstr "Referer 头从安全源发送到不安全目标。"

#: httplint/field/parsers/referer.py:18
msgid ""
"HTTP prohibits a user agent from sending a Referer header field in an "
"unsecured HTTP request\n"
"if the referring resource was accessed with a secure protocol.\n"
"\n"
"See [RFC 9110 Section 10.1.3](https://www.rfc-"
"editor.org/rfc/rfc9110.html#section-10.1.3)\n"
"for details."
msgstr ""
"HTTP 禁止用户代理在不安全 HTTP 请求中发送 Referer 报头字段，如果引用资源是通过安全协议访问的。\n"
"\n"
"详细信息请参阅 [RFC 9110 Section 10.1.3](https://www.rfc-"
"editor.org/rfc/rfc9110.html#section-10.1.3)。"

#: httplint/field/parsers/referer.py:29
msgid "The Referer header is sent from a secure origin to a different origin."
msgstr "Referer 头信息从一个安全源发送到另一个不同的源。"

#: httplint/field/parsers/referer.py:30
msgid ""
"HTTP prohibits a user agent from sending a Referer header field if the "
"referring resource was\n"
"accessed with a secure protocol and the request target has an origin "
"differing from that of the\n"
"referring resource, unless the referring resource explicitly allows "
"Referer to be sent.\n"
"\n"
"See [RFC 9110 Section 10.1.3](https://www.rfc-"
"editor.org/rfc/rfc9110.html#section-10.1.3)\n"
"for details."
msgstr ""
"HTTP 禁止用户代理在引用资源以安全协议访问且请求目标与引用资源的源不同时发送 Referer 标头字段，除非引用资源明确允许发送 "
"Referer。\n"
"\n"
"详情请参阅 [RFC 9110 Section 10.1.3](https://www.rfc-"
"editor.org/rfc/rfc9110.html#section-10.1.3)。"

#: httplint/field/parsers/referrer_policy.py:46
msgid "This response's Referrer-Policy allows unsafe URLs."
msgstr "此响应的 Referrer-Policy 允许不安全的 URL。"

#: httplint/field/parsers/referrer_policy.py:47
msgid ""
"Using `unsafe-url` in `Referrer-Policy` means that the full URL "
"(including query parameters) will\n"
"be sent as a referrer to all origins, including those that are not secure"
" (HTTP). This can leak\n"
"sensitive information."
msgstr ""
"在 `Referrer-Policy` 中使用 `unsafe-url` 意味着完整的 "
"URL（包括查询参数）将被发送为推荐人，发送给所有来源，包括不安全的来源（HTTP）。这可能会泄露敏感信息。"

#: httplint/field/parsers/referrer_policy.py:56
#, python-format
msgid "The Referrer-Policy value '%(policy)s' is unknown."
msgstr "Referrer-Policy 值 '%(policy)s' 未知。"

#: httplint/field/parsers/referrer_policy.py:57
#, python-format
msgid ""
"The `Referrer-Policy` header contains the value `%(policy)s`, which is "
"not a known referrer policy.\n"
"It will be ignored by browsers."
msgstr ""
"`Referrer-Policy` 標頭的值為 `%(policy)s`，這不是已知的 Referrer Policy。\n"
"瀏覽器將會忽略它。"

#: httplint/field/parsers/referrer_policy.py:65
msgid "No valid Referrer-Policy found."
msgstr "未找到有效的 Referrer-Policy。"

#: httplint/field/parsers/referrer_policy.py:66
msgid ""
"The `Referrer-Policy` header does not contain any valid policies. "
"Browsers will use their default\n"
"policy (usually `strict-origin-when-cross-origin`)."
msgstr ""
"`Referrer-Policy` 标头不包含任何有效策略。浏览器将使用其默认策略（通常是 `strict-origin-when-cross-"
"origin`）。"

#: httplint/field/parsers/referrer_policy.py:74
#, python-format
msgid "Multiple Referrer-Policy values found; only '%(effective)s' is used."
msgstr "找到多个 Referrer-Policy 值；仅使用 '%(effective)s'。"

#: httplint/field/parsers/referrer_policy.py:75
#, python-format
msgid ""
"The `Referrer-Policy` header contains multiple valid policies. Browsers "
"will only use the last\n"
"valid policy found, which is `%(effective)s`. Earlier values are ignored."
msgstr ""
"`Referrer-Policy` 标头包含多个有效策略。浏览器只会使用找到的最后一个有效策略，即 "
"`%(effective)s`。之前的选项将被忽略。"

#: httplint/field/parsers/server.py:43
msgid "The Server header is long."
msgstr "Server 标头过长。"

#: httplint/field/parsers/server.py:44
#, python-format
msgid ""
"The `Server` header is %(server_length)s long, which uses unnecessary "
"bandwidth\n"
"and can expose details of the back-end system to attackers.\n"
"\n"
"Consider shortening it."
msgstr ""
"`Server` 标头长度为 %(server_length)s，这会浪费不必要的带宽，并可能向攻击者暴露后端系统的详细信息。\n"
"\n"
"考虑缩短它。"

#: httplint/field/parsers/set_cookie.py:359
msgid "This response has a Set-Cookie header without a cookie-name."
msgstr "此响应的 Set-Cookie 标头缺少 cookie 名称。"

#: httplint/field/parsers/set_cookie.py:360
msgid ""
"This `Set-Cookie` header has an empty name; there needs to be a name "
"before the `=`.\n"
"\n"
"Browsers will ignore this cookie."
msgstr ""
"此 `Set-Cookie` 标头缺少名称；等号 (`=`) 前面需要有名称。\n"
"\n"
"浏览器将忽略此 Cookie。"

#: httplint/field/parsers/set_cookie.py:369
#, python-format
msgid "The %(cookie_name)s cookie has an invalid Expires date."
msgstr "%(cookie_name)s cookie 的Expires日期无效。"

#: httplint/field/parsers/set_cookie.py:370
msgid ""
"The `expires` date on this `Set-Cookie` header isn't valid; see\n"
"[RFC6265](https://www.rfc-editor.org/rfc/rfc6265) for details of the "
"correct format."
msgstr ""
"此 `Set-Cookie` 标头中的 `expires` 日期无效；请参阅\n"
"[RFC6265](https://www.rfc-editor.org/rfc/rfc6265) 了解正确格式的详细信息。"

#: httplint/field/parsers/set_cookie.py:378
#, python-format
msgid "The %(cookie_name)s cookie has an empty Max-Age."
msgstr "Cookie \"%(cookie_name)s\" 的 Max-Age 为空。"

#: httplint/field/parsers/set_cookie.py:379
msgid ""
"The `max-age` parameter on this `Set-Cookie` header doesn't have a value."
"\n"
"\n"
"Browsers will ignore the `max-age` value as a result."
msgstr ""
"此 `Set-Cookie` 标头上的 `max-age` 参数没有值。\n"
"\n"
"结果，浏览器将忽略 `max-age` 的值。"

#: httplint/field/parsers/set_cookie.py:388
#, python-format
msgid "The %(cookie_name)s cookie has a Max-Age with a leading zero."
msgstr "%(cookie_name)s Cookie 有一个 Max-Age，其开头有一个零。"

#: httplint/field/parsers/set_cookie.py:389
msgid ""
"The `max-age` parameter on this `Set-Cookie` header has a leading zero.\n"
"\n"
"Browsers will ignore the `max-age` value as a result."
msgstr ""
"此 `Set-Cookie` 标头中的 `max-age` 参数带有前导零。\n"
"\n"
"浏览器因此将忽略 `max-age` 值。"

#: httplint/field/parsers/set_cookie.py:398
#, python-format
msgid "The %(cookie_name)s cookie has a non-numeric Max-Age."
msgstr "%(cookie_name)s Cookie 的 Max-Age 不是数字。"

#: httplint/field/parsers/set_cookie.py:399
msgid ""
"The `max-age` parameter on this `Set-Cookie` header isn't numeric.\n"
"\n"
"Browsers will ignore the `max-age` value as a result."
msgstr ""
"此 `Set-Cookie` 标头上的 `max-age` 参数不是数字。\n"
"\n"
"浏览器因此会忽略 `max-age` 值。"

#: httplint/field/parsers/set_cookie.py:408
#, python-format
msgid "The %(cookie_name)s cookie has an empty domain."
msgstr "%(cookie_name)s Cookie 的 domain 为空。"

#: httplint/field/parsers/set_cookie.py:409
msgid ""
"The `domain` parameter on this `Set-Cookie` header is empty.\n"
"\n"
"Browsers will probably ignore it as a result."
msgstr ""
"`Set-Cookie` 标头中的 `domain` 参数为空。\n"
"\n"
"浏览器因此可能会忽略它。"

#: httplint/field/parsers/set_cookie.py:418
#, python-format
msgid "The %(cookie_name)s cookie is missing the Secure attribute."
msgstr "%(cookie_name)s cookie 缺少 Secure 属性。"

#: httplint/field/parsers/set_cookie.py:419
msgid ""
"The `Secure` attribute on this `Set-Cookie` header is missing.\n"
"\n"
"Browsers will ignore it."
msgstr ""
"此 `Set-Cookie` 标头中缺少 `Secure` 属性。\n"
"\n"
"浏览器将会忽略它。"

#: httplint/field/parsers/set_cookie.py:428
#, python-format
msgid "The %(cookie_name)s cookie has an unknown attribute, '%(attribute)s'."
msgstr "“%(cookie_name)s” cookie 具有一个未知属性，“%(attribute)s”。"

#: httplint/field/parsers/set_cookie.py:429
#, python-format
msgid ""
"This cookie has an extra parameter, \"%(attribute)s\".\n"
"\n"
"Browsers will ignore it."
msgstr ""
"此 Cookie 包含一个额外的参数：“%(attribute)s”。\n"
"\n"
"浏览器将忽略它。"

#: httplint/field/parsers/set_cookie.py:438
#, python-format
msgid ""
"The %(cookie_name)s cookie has an unknown '%(attribute_name)s' attribute "
"value."
msgstr "Cookie %(cookie_name)s 包含一个未知的“%(attribute_name)s”属性值。"

#: httplint/field/parsers/set_cookie.py:442
#, python-format
msgid ""
"This `Set-Cookie` header has an unknown \"%(attribute_name)s\" attribute "
"value, \"%(attribute_value)s\".\n"
"\n"
"Browsers will probably ignore it as a result."
msgstr ""
"此 `Set-Cookie` 标头包含一个未知的 \"%(attribute_name)s\" 属性值 "
"\"%(attribute_value)s\"。\n"
"\n"
"浏览器很可能会忽略它。"

#: httplint/field/parsers/set_cookie.py:451
#, python-format
msgid ""
"The %(cookie_name)s cookie has the Partitioned attribute but is missing "
"the Secure attribute."
msgstr "%(cookie_name)s cookie 具有 Partitioned 属性，但缺少 Secure 属性。"

#: httplint/field/parsers/set_cookie.py:455
msgid ""
"The `Partitioned` attribute on this `Set-Cookie` header is present, but "
"the `Secure` attribute is\n"
"missing.\n"
"\n"
"Browsers will ignore the `Partitioned` attribute as a result."
msgstr ""
"此 `Set-Cookie` 标头上的 `Partitioned` 属性已存在，但缺少 `Secure` 属性。\n"
"\n"
"结果，浏览器将忽略 `Partitioned` 属性。"

#: httplint/field/parsers/set_cookie.py:465
#, python-format
msgid "The %(cookie_name)s Set-Cookie header is too large."
msgstr "%(cookie_name)s Set-Cookie 标头过大。"

#: httplint/field/parsers/set_cookie.py:466
msgid ""
"The `Set-Cookie` header is larger than 4096 bytes.\n"
"\n"
"Browsers will ignore this cookie."
msgstr ""
"`Set-Cookie` 标头大于 4096 字节。\n"
"\n"
"浏览器将忽略此 Cookie。"

#: httplint/field/parsers/set_cookie.py:475
#, python-format
msgid "The %(cookie_name)s Set-Cookie value is large."
msgstr "%(cookie_name)s Set-Cookie 值过大。"

#: httplint/field/parsers/set_cookie.py:476
#, python-format
msgid ""
"The `Set-Cookie` value is %(set_cookie_value_length)s long.\n"
"\n"
"This may be wasteful."
msgstr ""
"`Set-Cookie` 的值长度为 %(set_cookie_value_length)s。\n"
"\n"
"这可能很浪费。"

#: httplint/field/parsers/set_cookie.py:492
#, python-format
msgid "The %(cookie_name)s Set-Cookie header has a lifetime that is too long."
msgstr "%(cookie_name)s Set-Cookie 标头中的有效期过长。"

#: httplint/field/parsers/set_cookie.py:493
msgid ""
"The `Set-Cookie` header has a lifetime (Max-Age or Expires) that is "
"greater than 400 days.\n"
"\n"
"Browsers will cap the lifetime to 400 days."
msgstr ""
"`Set-Cookie` 标头具有大于 400 天的生命周期（Max-Age 或 Expires）。\n"
"\n"
"浏览器会将生命周期上限设置为 400 天。"

#: httplint/field/parsers/set_cookie.py:502
#, python-format
msgid "The %(cookie_name)s Set-Cookie header requires the Secure attribute."
msgstr "%(cookie_name)s Set-Cookie 标头需要 Secure 属性。"

#: httplint/field/parsers/set_cookie.py:503
msgid ""
"The `Set-Cookie` header has a prefix (e.g., `__Secure-` or `__Host-`) "
"that requires the `Secure`\n"
"attribute.\n"
"\n"
"Browsers will reject this cookie."
msgstr ""
"`Set-Cookie` 标头具有需要 `Secure` 属性的前缀（例如 `__Secure-` 或 `__Host-`）。\n"
"\n"
"浏览器将拒绝此 cookie。"

#: httplint/field/parsers/set_cookie.py:513
#, python-format
msgid ""
"The %(cookie_name)s Set-Cookie header has a __Host- prefix but sets a "
"Domain."
msgstr "%(cookie_name)s Set-Cookie 标头具有 __Host- 前缀但设置了 Domain。"

#: httplint/field/parsers/set_cookie.py:516
msgid ""
"The `Set-Cookie` header has a `__Host-` prefix, but it sets a `Domain` "
"attribute.\n"
"\n"
"Browsers will reject this cookie."
msgstr ""
"`Set-Cookie` 标头具有 `__Host-` 前缀，但它设置了 `Domain` 属性。\n"
"\n"
"浏览器将拒绝此 Cookie。"

#: httplint/field/parsers/set_cookie.py:525
#, python-format
msgid ""
"The %(cookie_name)s Set-Cookie header has a __Host- prefix but does not "
"set Path=/."
msgstr "%(cookie_name)s Set-Cookie 标头包含 __Host- 前缀，但未设置 Path=/."

#: httplint/field/parsers/set_cookie.py:526
msgid ""
"The `Set-Cookie` header has a `__Host-` prefix, but it does not set "
"`Path=/`.\n"
"\n"
"Browsers will reject this cookie."
msgstr ""
"`Set-Cookie` 標頭具有 `__Host-` 前綴，但未設定 `Path=/`。\n"
"\n"
"瀏覽器將拒絕此 cookie。"

#: httplint/field/parsers/set_cookie.py:535
#, python-format
msgid ""
"The %(cookie_name)s Set-Cookie header has duplicate '%(attribute)s' "
"attributes."
msgstr "Set-Cookie 标头中的 %(cookie_name)s 包含重复的 “%(attribute)s” 属性。"

#: httplint/field/parsers/set_cookie.py:536
#, python-format
msgid ""
"The `%(attribute)s` attribute appears more than once in this `Set-Cookie`"
" header.\n"
"\n"
"Browsers will only use the last occurrence."
msgstr ""
"`%(attribute)s` 属性在此 `Set-Cookie` 标头中出现多次。\n"
"\n"
"浏览器只会使用最后一次出现的值。"

#: httplint/field/parsers/set_cookie.py:545
msgid "This response sets duplicate cookies."
msgstr "此响应设置了重复的 Cookie。"

#: httplint/field/parsers/set_cookie.py:546
#, python-format
msgid ""
"The following cookies are set more than once in this response: "
"%(cookie_names)s.\n"
"\n"
"Browsers will likely accept all of them, but the order of application\n"
"may vary or be confusing."
msgstr ""
"以下 Cookie 在此响应中设置了多次：%(cookie_names)s。\n"
"\n"
"浏览器很可能接受所有这些 Cookie，但应用顺序可能会有所不同或令人困惑。"

#: httplint/field/parsers/strict_transport_security.py:129
msgid "Strict Transport Security (HSTS) is enabled."
msgstr "严格传输安全 (HSTS) 已启用。"

#: httplint/field/parsers/strict_transport_security.py:130
msgid ""
"This site has enabled HTTP Strict Transport Security (HSTS), which tells "
"the browser to only\n"
"communicate with it over a secure connection."
msgstr "此网站已启用 HTTP 严格传输安全 (HSTS)，它会指示浏览器仅通过安全连接与其通信。"

#: httplint/field/parsers/strict_transport_security.py:138
msgid "This response's Strict Transport Security (HSTS) header is invalid."
msgstr "此响应的 Strict Transport Security (HSTS) 标头无效。"

#: httplint/field/parsers/strict_transport_security.py:139
msgid ""
"This site has attempted to enable HTTP Strict Transport Security (HSTS), "
"which tells the browser to only\n"
"communicate with it over a secure connection.\n"
"\n"
"However, one or more issues prevent it from being valid. See the child "
"notes for details."
msgstr ""
"此网站试图启用 HTTP Strict Transport Security (HSTS)，它会告知浏览器仅通过安全连接与其通信。\n"
"\n"
"然而，一个或多个问题阻止其生效。请参阅子节点了解详情。"

#: httplint/field/parsers/strict_transport_security.py:149
msgid "There is no max-age directive."
msgstr "没有 max-age 指令。"

#: httplint/field/parsers/strict_transport_security.py:150
msgid ""
"The `Strict-Transport-Security` header requires a `max-age` directive to "
"be valid."
msgstr "`Strict-Transport-Security` 标头需要 `max-age` 指令才有效。"

#: httplint/field/parsers/strict_transport_security.py:157
msgid "The max-age is 0."
msgstr "max-age 为 0。"

#: httplint/field/parsers/strict_transport_security.py:158
msgid ""
"A `max-age` of 0 tells the browser to expire the `Strict-Transport-"
"Security` policy immediately,\n"
"effectively disabling it."
msgstr ""
"`max-age` 为 0 会告诉浏览器立即使 `Strict-Transport-Security` 策略失效，\n"
"从而有效地禁用它。"

#: httplint/field/parsers/strict_transport_security.py:166
msgid "The max-age is less than one year."
msgstr "max-age 小于一年。"

#: httplint/field/parsers/strict_transport_security.py:167
msgid ""
"Most sites should set a `max-age` of at least one year on `Strict-"
"Transport-Security`."
msgstr "大多数网站都应该在 `Strict-Transport-Security` 中设置至少一年的 `max-age`。"

#: httplint/field/parsers/strict_transport_security.py:174
msgid "HSTS applies to subdomains."
msgstr "HSTS 适用于子域名。"

#: httplint/field/parsers/strict_transport_security.py:175
msgid ""
"The `includeSubDomains` directive indicates that this HSTS policy applies"
" to this domain as well as\n"
"all of its subdomains."
msgstr "`includeSubDomains` 指令表明此 HSTS 策略也适用于此域及其所有子域。"

#: httplint/field/parsers/strict_transport_security.py:183
msgid "HSTS doesn't apply to subdomains."
msgstr "HSTS 不适用于子域。"

#: httplint/field/parsers/strict_transport_security.py:184
msgid ""
"The `includeSubDomains` directive indicates that this HSTS policy applies"
" to this domain as well as\n"
"all of its subdomains.\n"
"\n"
"Because cookies can be set across HTTP and HTTPS sites as well as across "
"subdomains, this means \n"
"that an attacker might be able to take advantage of a subdomain that "
"doesn't have HSTS enabled.\n"
msgstr ""
"`includeSubDomains` 指令表示此 HSTS 策略也适用于本域及其所有子域。\n"
"\n"
"由于 cookie 可以在 HTTP 和 HTTPS 网站之间设置，也可以在子域之间设置，因此这意味着攻击者可能能够利用未启用 HSTS 的子域。"

#: httplint/field/parsers/strict_transport_security.py:196
msgid "Browser preloading is allowed."
msgstr "浏览器预加载是允许的。"

#: httplint/field/parsers/strict_transport_security.py:197
msgid ""
"The `preload` directive on `Strict-Transport-Security` allows browsers to"
" preload the site in\n"
"its HSTS lists, avoiding the potential for making unencrypted requests "
"when first accessing the\n"
"site.\n"
"\n"
"See the [HSTS Preload List](https://hstspreload.org/) for more "
"information.\n"
msgstr ""
"`Strict-Transport-Security` 上的 `preload` 指令允许浏览器在\n"
"其 HSTS 列表中预加载网站，从而避免在首次访问网站时发出未加密请求的可能性。\n"
"\n"
"有关更多信息，请参阅 [HSTS 预加载列表](https://hstspreload.org/)。"

#: httplint/field/parsers/strict_transport_security.py:209
msgid "Browser preloading is allowed, but this policy isn't suitable for it."
msgstr "浏览器预加载是允许的，但此策略不适合它。"

#: httplint/field/parsers/strict_transport_security.py:210
msgid ""
"Preloading a site in a browser's HSTS list requires a `max-age` of at "
"least one year and the\n"
"`includeSubDomains` directive.\n"
"\n"
"See the [HSTS Preload List](https://hstspreload.org/) for more "
"information.\n"
msgstr ""
"在浏览器 HSTS 列表中预加载网站需要 `max-age` 至少为一年，并包含 `includeSubDomains` 指令。\n"
"\n"
"有关更多信息，请参阅 [HSTS 预加载列表](https://hstspreload.org/)。"

#: httplint/field/parsers/strict_transport_security.py:221
msgid "Browser preloading isn't allowed."
msgstr "浏览器预加载不允许。"

#: httplint/field/parsers/strict_transport_security.py:222
msgid ""
"Without a `preload` directive, browsers may make an unencrypted request "
"when first accessing the\n"
"site, potentially exposing sensitive information.\n"
"\n"
"See the [HSTS Preload List](https://hstspreload.org/) for more "
"information.\n"
msgstr ""
"如果没有 `preload` 指令，浏览器在首次访问网站时可能会发出未加密的请求，从而可能暴露敏感信息。\n"
"\n"
"有关更多信息，请参阅 [HSTS Preload List](https://hstspreload.org/)。"

#: httplint/field/parsers/strict_transport_security.py:233
msgid "The HSTS header contains a duplicate directive."
msgstr "HSTS 头部包含重复指令。"

#: httplint/field/parsers/strict_transport_security.py:234
#, python-format
msgid ""
"The `%(directive)s` directive appears more than once in the `Strict-"
"Transport-Security` header.\n"
"Directives must only appear once."
msgstr ""
"`%(directive)s` 指令在 `Strict-Transport-Security` 标头中出现不止一次。\n"
"指令只能出现一次。"

#: httplint/field/parsers/strict_transport_security.py:242
msgid "The HSTS header is sent over HTTP."
msgstr "HSTS 头部通过 HTTP 发送。"

#: httplint/field/parsers/strict_transport_security.py:243
msgid ""
"The `Strict-Transport-Security` header is ignored when sent over HTTP, "
"unless it's a 301 Redirect.\n"
"It should only be sent over HTTPS."
msgstr ""
"`Strict-Transport-Security` 头部在通过 HTTP 发送时会被忽略，除非它是 301 重定向。\n"
"它应该仅通过 HTTPS 发送。"

#: httplint/field/parsers/strict_transport_security.py:251
msgid "This response has multiple HSTS headers."
msgstr "此响应有多个 HSTS 标头。"

#: httplint/field/parsers/strict_transport_security.py:252
msgid ""
"A response should only contain a single `Strict-Transport-Security` "
"header.\n"
"User agents are required to process only the first one and ignore the "
"rest."
msgstr ""
"响应应只包含一个 `Strict-Transport-Security` 报头。\n"
"用户代理被要求只处理第一个，并忽略其余的。"

#: httplint/field/parsers/strict_transport_security.py:260
msgid "The max-age directive in the HSTS header is invalid."
msgstr "HSTS 标头中的 max-age 指令无效。"

#: httplint/field/parsers/strict_transport_security.py:261
#, python-format
msgid ""
"The `max-age` directive in the `Strict-Transport-Security` header must be"
" a non-negative\n"
"integer. The value \"%(max_age)s\" is not valid."
msgstr ""
"`Strict-Transport-Security` 标头中的 `max-age` 指令必须是一个非负整数。值 \"%(max_age)s\" "
"无效。"

#: httplint/field/parsers/strict_transport_security.py:269
#, python-format
msgid "The %(directive)s directive in the HSTS header must not have a value."
msgstr "HSTS 标头中的 %(directive)s 指令不得具有值。"

#: httplint/field/parsers/strict_transport_security.py:270
#, python-format
msgid ""
"The `%(directive)s` directive in the `Strict-Transport-Security` header "
"is a valueless\n"
"directive. It should not have an associated value."
msgstr "`Strict-Transport-Security` 标头中的 `%(directive)s` 指令是一个无值的指令。它不应有相关的值。"

#: httplint/field/parsers/transfer_encoding.py:54
msgid "The identity transfer-coding isn't necessary."
msgstr "身份传输编码不是必需的。"

#: httplint/field/parsers/transfer_encoding.py:55
msgid ""
"HTTP defines _transfer-codings_ as a hop-by-hop encoding of the message's"
" content. The `identity`\n"
"transfer-coding was defined as the absence of encoding; it doesn't do "
"anything, so it is unnecessary.\n"
"\n"
"You can remove this token to save a few bytes."
msgstr ""
"HTTP 将 _transfer-codings_ 定义为消息内容的逐跳编码。`identity` "
"传输编码被定义为不编码；它不做任何事，所以是不必要的。\n"
"\n"
"您可以删除此令牌以节省几个字节。"

#: httplint/field/parsers/transfer_encoding.py:65
msgid "This message has unsupported transfer-coding."
msgstr "此消息具有不受支持的传输编码。"

#: httplint/field/parsers/transfer_encoding.py:66
#, python-format
msgid ""
"This message's `Transfer-Encoding` header indicates it has transfer-"
"codings applied, but the\n"
"request didn't ask for it (or them) to be.\n"
"\n"
"They are: `%(unwanted_codings)s`\n"
"\n"
"Normally, clients ask for the encodings they want in the `TE` request "
"header. Using codings that\n"
"the client doesn't explicitly request can lead to interoperability "
"problems."
msgstr ""
"此消息的 `Transfer-Encoding` 标头表明它已应用了传输编码，但请求并未要求应用（或它们）。\n"
"\n"
"它们是： `%(unwanted_codings)s`\n"
"\n"
"通常，客户端会在 `TE` 请求标头中请求它们想要的编码。使用客户端未明确请求的编码可能导致互操作性问题。"

#: httplint/field/parsers/transfer_encoding.py:79
msgid "This message had parameters on its transfer-codings."
msgstr "此消息的 transfer-codings 带有参数。"

#: httplint/field/parsers/transfer_encoding.py:80
msgid ""
"HTTP allows transfer-codings in the `Transfer-Encoding` header to have "
"optional parameters, but it\n"
"doesn't define what they mean.\n"
"\n"
"This message has encodings with such parameters; although they're "
"technically allowed, they may\n"
"cause interoperability problems. They should be removed."
msgstr ""
"HTTP 允许 `Transfer-Encoding` 标头中的传输编码具有可选参数，但它没有定义这些参数的含义。\n"
"\n"
"此消息包含带有此类参数的编码；尽管它们在技术上是允许的，但可能会导致互操作性问题。应将其删除。"

#: httplint/field/parsers/vary.py:43
msgid "Vary: * effectively makes this response uncacheable."
msgstr "Vary: * 有效地使此响应不可缓存。"

#: httplint/field/parsers/vary.py:44
msgid ""
"`Vary *` indicates that responses for this resource vary by some aspect "
"that can't (or won't) be\n"
"described by the server. This makes this response effectively uncacheable."
msgstr "`Vary *` 表明此资源的响应因服务器无法（或不愿）描述的某些方面而异。这使得此响应实际上不可缓存。"

#: httplint/field/parsers/vary.py:52
msgid "Vary: User-Agent can cause cache inefficiency."
msgstr "Vary: User-Agent 可能导致缓存效率低下。"

#: httplint/field/parsers/vary.py:53
msgid ""
"Sending `Vary: User-Agent` requires caches to store a separate copy of "
"the response for every\n"
"`User-Agent` request header they see.\n"
"\n"
"Since there are so many different `User-Agent`s, this can \"bloat\" "
"caches with many copies of the\n"
"same thing, or cause them to give up on storing these responses at all.\n"
"\n"
"Consider having different URIs for the various versions of your content "
"instead; this will give\n"
"finer control over caching without sacrificing efficiency."
msgstr ""
"发送 `Vary: User-Agent` 会要求缓存为它们看到的每个 `User-Agent` 请求头单独存储一份响应副本。\n"
"\n"
"由于 `User-Agent` 非常多，这会“膨胀”缓存，存储大量相同的副本，或者导致缓存放弃存储这些响应。\n"
"\n"
"请考虑为您的内容的各种版本使用不同的 URI；这样可以在不牺牲效率的情况下更精细地控制缓存。"

#: httplint/field/parsers/vary.py:67
msgid "Vary: Host is not necessary."
msgstr "Vary: Host 不需要。"

#: httplint/field/parsers/vary.py:68
msgid ""
"Some servers (e.g., [Apache](http://httpd.apache.org/) with\n"
"[mod_rewrite](http://httpd.apache.org/docs/2.4/mod/mod_rewrite.html)) "
"will send `Host` in the\n"
"`Vary` header, in the belief that this is necessary.\n"
"\n"
"This is not the case; HTTP specifies that the URI is the basis of the "
"cache key, and the URI\n"
"incorporates the `Host` header.\n"
"\n"
"The presence of `Vary: Host` may make some caches not store an otherwise "
"cacheable response (since\n"
"some cache implementations will not store anything that has a `Vary` "
"header)."
msgstr ""
"有些服务器（例如，[Apache](http://httpd.apache.org/) 配合 "
"[mod_rewrite](http://httpd.apache.org/docs/2.4/mod/mod_rewrite.html)）会发送 "
"`Host` 作为 `Vary` 头部字段，认为这是必要的。\n"
"\n"
"事实并非如此；HTTP 规定 URI 是缓存键的基础，而 URI 包含了 `Host` 头部字段。\n"
"\n"
"`Vary: Host` 的存在可能会导致某些缓存不存储本可缓存的响应（因为有些缓存实现不会存储带有 `Vary` 头部字段的任何内容）。"

#: httplint/field/parsers/vary.py:83
msgid "Transparent Content Negotiation is not widely supported."
msgstr "透明内容协商（Transparent Content Negotiation）支持不广泛。"

#: httplint/field/parsers/vary.py:84
msgid ""
"The `Vary: Negotiate` header value is not necessary, as \n"
"[Transparent Content Negotiation](https://www.rfc-"
"editor.org/rfc/rfc2295.html)\n"
"is not widely supported.\n"
"\n"
"Consider removing it."
msgstr ""
"`Vary: Negotiate` 标头值并非必需，因为[透明内容协商](https://www.rfc-"
"editor.org/rfc/rfc2295.html) 并未得到广泛支持。\n"
"\n"
"考虑移除它。"

#: httplint/field/parsers/vary.py:95
#, python-format
msgid "This resource varies in %(vary_count)s ways."
msgstr "此资源在 %(vary_count)s 个方面有所不同。"

#: httplint/field/parsers/vary.py:96
msgid ""
"The `Vary` mechanism allows a resource to describe the dimensions that "
"its responses vary, or\n"
"change, over; each listed header is another dimension.\n"
"\n"
"Varying by too many dimensions makes using this information impractical."
msgstr ""
"`Vary` 机制允许资源描述其响应变化（或改变）的维度；列出的每个头字段代表一个维度。\n"
"\n"
"变化维度过多会使使用此信息变得不切实际。"

#: httplint/field/parsers/via.py:33
msgid "One or more intermediaries are present."
msgstr "存在一个或多个中间服务器。"

#: httplint/field/parsers/via.py:34
msgid ""
"The `Via` header indicates that one or more intermediaries are present "
"between the user agent and\n"
"the origin server for the resource.\n"
"\n"
"This may indicate that a proxy is configured, or that the server uses a "
"\"reverse proxy\" or CDN in\n"
"front of it.\n"
"\n"
"There field has three space-separated components; first, the HTTP version"
" of the message that the\n"
"intermediary received, then the identity of the intermediary (usually but"
" not always its hostname),\n"
"and then optionally a product identifier or comment (usually used to "
"identify the software being\n"
"used)."
msgstr ""
"`Via` 报头表明用户代理和资源源服务器之间存在一个或多个中间服务器。\n"
"\n"
"这可能表明配置了代理，或者服务器在其前面使用了“反向代理”或 CDN。\n"
"\n"
"该字段由三个用空格分隔的组件组成；首先是中间服务器接收到的消息的 HTTP "
"版本，然后是中间服务器的标识（通常是其主机名，但不总是），最后是可选的产品标识符或注释（通常用于识别所使用的软件）。"

#: httplint/field/parsers/x_content_type_options.py:29
msgid "This response instructs browsers not to 'sniff' its media type."
msgstr "此响应指示浏览器不要“嗅探”其媒体类型。"

#: httplint/field/parsers/x_content_type_options.py:32
msgid ""
"Many Web browsers \"sniff\" the media type of responses to figure out "
"whether they're HTML, RSS or\n"
"another format, no matter what the `Content-Type` header says.\n"
"\n"
"This header instructs browsers not to do this, but to always respect the\n"
"Content-Type header. It probably won't have any effect in other clients.\n"
"\n"
"See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X"
"-Content-Type-Options)\n"
"for more information about this header."
msgstr ""
"许多 Web 浏览器会“嗅探”响应的媒体类型，以确定它是 HTML、RSS 还是其他格式，而不管 `Content-Type` 标头说了什么。\n"
"\n"
"此标头指示浏览器不要这样做，而是始终遵守 `Content-Type` 标头。它可能不会在其他客户端中产生任何影响。\n"
"\n"
"有关此标头的更多信息，请参阅 [MDN](https://developer.mozilla.org/en-"
"US/docs/Web/HTTP/Headers/X-Content-Type-Options)。"

#: httplint/field/parsers/x_content_type_options.py:46
msgid "X-Content-Type-Options contains an unknown value."
msgstr "X-Content-Type-Options 包含一个未知值。"

#: httplint/field/parsers/x_content_type_options.py:49
msgid ""
"Only one value is currently defined for this header, `nosniff`. Using "
"other values here won't\n"
"necessarily cause problems, but they probably won't have any effect "
"either.\n"
"\n"
"See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X"
"-Content-Type-Options)\n"
"for more information about this header."
msgstr ""
"此标头目前仅定义了一个值 `nosniff`。在此处使用其他值不一定会导致问题，但很可能也不会产生任何效果。\n"
"\n"
"有关此标头的更多信息，请参阅 [MDN](https://developer.mozilla.org/en-"
"US/docs/Web/HTTP/Headers/X-Content-Type-Options)。"

#: httplint/field/parsers/x_frame_options.py:53
msgid "This response prevents some browsers from rendering it within a frame."
msgstr "此响应可阻止部分浏览器将其渲染在框架内。"

#: httplint/field/parsers/x_frame_options.py:56
msgid ""
"The `X-Frame-Options` response header controls how IE8 handles HTML "
"frames; the `DENY` value\n"
"prevents this content from being rendered within a frame, which defends "
"against certain types of\n"
"attacks.\n"
"\n"
"See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X"
"-Frame-Options) for more information.\n"
msgstr ""
"`X-Frame-Options` 响应头控制 IE8 如何处理 HTML 框架；`DENY` "
"值可防止此内容在框架内渲染，从而防御某些类型的攻击。\n"
"\n"
"有关更多信息，请参阅 [MDN](https://developer.mozilla.org/en-"
"US/docs/Web/HTTP/Headers/X-Frame-Options)。"

#: httplint/field/parsers/x_frame_options.py:68
msgid ""
"This response prevents some browsers from rendering it within a frame on "
"another site."
msgstr "此响应可阻止某些浏览器在其网站框架中呈现它。"

#: httplint/field/parsers/x_frame_options.py:74
msgid ""
"The `X-Frame-Options` response header controls how IE8 handles HTML "
"frames; the `DENY` value\n"
"prevents this content from being rendered within a frame on another site,"
" which defends against\n"
"certain types of attacks.\n"
"\n"
"Currently this is supported by IE8 and Safari 4.\n"
"\n"
"See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X"
"-Frame-Options) for more information.\n"
msgstr ""
"`X-Frame-Options` 响应头控制 IE8 如何处理 HTML 框架；`DENY` "
"值可以防止此内容在其他网站的框架中呈现，从而防御某些类型的攻击。\n"
"\n"
"目前 IE8 和 Safari 4 支持此功能。\n"
"\n"
"有关更多信息，请参阅 [MDN](https://developer.mozilla.org/en-"
"US/docs/Web/HTTP/Headers/X-Frame-Options)。"

#: httplint/field/parsers/x_frame_options.py:88
msgid "The X-Frame-Options header contains an unknown value."
msgstr "X-Frame-Options 标头包含一个未知值。"

#: httplint/field/parsers/x_frame_options.py:91
msgid ""
"Only two values are currently defined for this header, `DENY` and "
"`SAMEORIGIN`. Using other values\n"
"here won't necessarily cause problems, but they probably won't have any "
"effect either.\n"
"\n"
"See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X"
"-Frame-Options) for more information.\n"
msgstr ""
"该标头目前仅定义了两个值：`DENY` 和 `SAMEORIGIN`。在此使用其他值不一定会导致问题，但它们可能也没有任何效果。\n"
"\n"
"有关更多信息，请参阅 [MDN](https://developer.mozilla.org/en-"
"US/docs/Web/HTTP/Headers/X-Frame-Options)。"

